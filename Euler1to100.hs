-- Project Euler problem solutions from 1 to 100.
-- By Truman Collins
-- April 19, 2014 to April 23, 2016

-- The following packages are needed to compile this:
-- cabal install containers
-- cabal install vector
-- cabal install heap
-- cabal install hashmap
-- cabal install fgl  (for graph functions)
-- cabal install parallel

{-# Language TupleSections #-}
{-# Language BangPatterns #-}

module Euler1to100 (
  prob001,
  prob002,
  prob003,
  prob004,
  prob005,
  prob006,
  prob007,
  prob008,
  prob009,
  prob010,
  prob011,
  prob012,
  prob013,
  prob014,
  prob015,
  prob016,
  prob017,
  prob018,
  prob019,
  prob020,
  prob021,
  prob022,
  prob023,
  prob024,
  prob025,
  prob026,
  prob027,
  prob028,
  prob029,
  prob030,
  prob031,
  prob032,
  prob033,
  prob034,
  prob035,
  prob036,
  prob037,
  prob038,
  prob039,
  prob040,
  prob041,
  prob042,
  prob043,
  prob044,
  prob045,
  prob046,
  prob047,
  prob048,
  prob049,
  prob050,
  prob051,
  prob052,
  prob053,
  prob054,
  prob055,
  prob056,
  prob057,
  prob058,
  prob059,
  prob060,
  prob061,
  prob062,
  prob063,
  prob064,
  prob065,
  prob066,
  prob067,
  prob068,
  prob069,
  prob070,
  prob071,
  prob072,
  prob073,
  prob074,
  prob075,
  prob076,
  prob077,
  prob078,
  prob079,
  prob080,
  prob081,
  prob082,
  prob083,
  prob084,
  prob085,
  prob086,
  prob087,
  prob088,
  prob089,
  prob090,
  prob091,
  prob092,
  prob093,
  prob094,
  prob095,
  prob096,
  prob097,
  prob098,
  prob099,
  prob100
) where

import Data.Char
import Data.Int
import Data.Bits
import Data.Ratio
import Data.List
import Data.Maybe
import qualified Data.Heap as HP
import qualified Data.Array as BA
import qualified Data.Array.Unboxed as UA
import qualified Data.Vector as V
import qualified Data.Vector.Unboxed as UV
import qualified Data.Map.Strict as M
import qualified Data.HashMap.Strict as HMS
import qualified Data.Bifunctor as BF
import qualified Data.Graph.Inductive.Graph as GR
import qualified Data.Graph.Inductive.PatriciaTree as GRPT
import qualified Data.Graph.Inductive.Query.SP as GRSP
import qualified Data.ByteString.Char8 as BC
import Control.Monad
import Control.Parallel.Strategies
import EulerUtil
import PrimeMod

-- If we list all the natural numbers below 10 that are multiples of 3 or 5,
-- we get 3, 5, 6 and 9. The sum of these multiples is 23.  Find the sum of
-- all the multiples of 3 or 5 below 1000.
-- I tried four ways of doing the fold, and found that using foldl1' was 
-- generally better than using foldl', and just using (+) rather than a
-- simple lambda function was better as well.  The timings were about the
-- same for foldl1' (lambda), foldl' (+), and foldl1' (+), so I suspect that
-- the compiler can fully optimize one slowdown but not both.

prob001 :: Int
prob001 = result
  where
    skipsBetweenMultiples = cycle [3, 2, 1, 3, 1, 2, 3]
    multOfThreeOrFive = scanl (+) 0 skipsBetweenMultiples
    underLimit = takeWhile (< 1000) multOfThreeOrFive
    result     = foldl1' (+) underLimit

-- Each new term in the Fibonacci sequence is generated by adding the previous
-- two terms. By starting with 1 and 2, the first 10 terms will be:
--     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
-- By considering the terms in the Fibonacci sequence whose values do not
-- exceed four million, find the sum of the even-valued terms.
    
-- As with the last one, the use of foldl1' (+) seems simplest and fastest.
                                                                               
prob002 :: Int
prob002 = result
  where
    result = foldl1' (+) underLimit
    underLimit = takeWhile (<= 4000000) even_fibb_numbers
    even_fibb_numbers = filter even myFibNumbers

-- The prime factors of 13195 are 5, 7, 13 and 29.
-- What is the largest prime factor of the number 600851475143?

prob003 :: PrimeT
prob003 = result
  where
    targetNumber = 600851475143 :: Int64
    result = maximum (myPrimeFactors targetNumber)

-- A palindromic number reads the same both ways. The largest palindrome
-- made from the product of two 2-digit numbers is 9009 = 91 × 99.
-- Find the largest palindrome made from the product of two 3-digit numbers.

-- The strategy here is to search through all three-digit numbers starting
-- from the largest pairs, but don't search cases where the product is less
-- than the best we've already found.
    
prob004 :: Int
prob004 = prod
  where
    (_, _, prod) = search 999 999 (0, 0, 0)
    search :: Int -> Int -> (Int, Int, Int) -> (Int, Int, Int)
    search n1 n2 (b1, b2, bProd)
      | bProd `seq` (n1 < 100) = (b1, b2, bProd)
      | n2 < 100 || nProd <= bProd = search nextN1 restartN2 (b1, b2, bProd)
      | palindromic nProd = search nextN1 restartN2 (n1, n2, nProd)
      | otherwise = search n1 nextN2 (b1, b2, bProd)
      where
        nextN1 = n1 - 1
        nextN2 = n2 - 1
        restartN2 = nextN1
        nProd = n1 * n2

-- 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any
-- remainder.  What is the smallest positive number that is evenly divisible by all of the numbers
-- from 1 to 20?

prob005 :: Int
prob005 = result
  where
    result = 1 * 2 * 3 * 2 * 5 * 7 * 2 * 3 * 11 * 13 * 2 * 17 * 19
    
-- The sum of the squares of the first ten natural numbers is,
--   1^2 + 2^2 + ... + 10^2 = 385
-- The square of the sum of the first ten natural numbers is,
--   (1 + 2 + ... + 10)^2 = 55^2 = 3025
-- Hence the difference between the sum of the squares of the first ten
-- natural numbers and the square of the sum is 3025 − 385 = 2640.
-- Find the difference between the sum of the squares of the first one
-- hundred natural numbers and the square of the sum.

prob006 :: Int
prob006 = sum [1..100] ^ (2 :: Int) - sum [x ^ (2 :: Int) | x <- [1..100]]

-- By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is
-- 13.  What is the 10 001st prime number?
      
prob007 :: PrimeT
prob007 = myPrimes !! 10000

prob008Input :: BC.ByteString
prob008Input = BC.pack
  "73167176531330624919225119674426574742355349194934\
  \96983520312774506326239578318016984801869478851843\
  \85861560789112949495459501737958331952853208805511\
  \12540698747158523863050715693290963295227443043557\
  \66896648950445244523161731856403098711121722383113\
  \62229893423380308135336276614282806444486645238749\
  \30358907296290491560440772390713810515859307960866\
  \70172427121883998797908792274921901699720888093776\
  \65727333001053367881220235421809751254540594752243\
  \52584907711670556013604839586446706324415722155397\
  \53697817977846174064955149290862569321978468622482\
  \83972241375657056057490261407972968652414535100474\
  \82166370484403199890008895243450658541227588666881\
  \16427171479924442928230863465674813919123162824586\
  \17866458359124566529476545682848912883142607690042\
  \24219022671055626321111109370544217506941658960408\
  \07198403850962455444362981230987879927244284909188\
  \84580156166097919133875499200524063689912560717606\
  \05886116467109405077541002256983155200055935729725\
  \71636269561882670428252483600823257530420752963450"

prob008 :: Int64
prob008 = snd (BC.foldl' processChar (1 : replicate (len - 1) 0, 0) prob008Input)
  where
    len = 13
    processChar :: ([Int64], Int64) -> Char -> ([Int64], Int64)
    processChar (currVals, maxVal) char = newMaxVal `seq` (prodsNextIter, newMaxVal)
      where
        prodsNextIter = tail newProds
        newMaxVal  = max (head newProds) maxVal
        newProds   = multByDigAndOneAtEnd currVals
        digVal     = fromIntegral (ord char - ord '0')
        multByDigAndOneAtEnd [] = [1]
        multByDigAndOneAtEnd (x : xs) = (digVal * x) : multByDigAndOneAtEnd xs

-- A Pythagorean triplet is a set of three natural numbers, 
-- a  b  c, for which, a^2 + b^2 = c^2
-- For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
-- There exists exactly one Pythagorean triplet for which 
-- a + b + c = 1000.  Find the product a*b*c.
         
prob009 :: Int
prob009 = a * b * c
  where
    wantedPerimeter = 1000
    (a, b, c) = head (filter (\(a', b', c') -> a'+b'+c' == wantedPerimeter)
                (pythagoreanTriplesPrimTree (ptptWithinLimitPerimeter wantedPerimeter)))

prob010 :: Int64
prob010 = sumPrimesBelow myPrimes 0
  where
    limit = 2000000
    sumPrimesBelow :: [PrimeT] -> Int64 -> Int64
    sumPrimesBelow [] _ = 0  -- This will never happen, but keeps the compiler happy.
    sumPrimesBelow (p : ps) sm
      | p < limit = sumPrimesBelow ps newSum
      | otherwise = sm
      where
        !newSum = sm + fromIntegral p
                    
-- In the 20x20 grid below, four numbers along a diagonal line have been marked in red.
--
-- 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
-- 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
-- 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
-- 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
-- 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
-- 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
-- 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
-- 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
-- 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
-- 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
-- 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
-- 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
-- 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
-- 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
-- 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
-- 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
-- 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
-- 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
-- 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
-- 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
-- 
-- The product of these numbers is 26  63  78  14 = 1788696.
-- 
-- What is the greatest product of four adjacent numbers in the same direction
-- (up, down, left, right, or diagonally) in the 2020 grid?

prob11List :: [((Int, Int), Int)] 
prob11List = zip
    [(x,y) | x <- [0..19], y <- [0..19]]
    [08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
     49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
     81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
     52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
     22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
     24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
     32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
     67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
     24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
     21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
     78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
     16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
     86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
     19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
     04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
     88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
     04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
     20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
     20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
     01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]

prob11Array :: UA.UArray (Int, Int) Int
prob11Array = UA.array ((0,0), (19,19)) prob11List

prob011 :: Int
prob011 = scanForMax4 0 0 accumsAndTransforms 0
  where
    scanForMax4 :: Int -> Int -> [((Int, Int, Int, Int), Int -> Int -> (Int, Int))] -> Int -> Int
    scanForMax4 ind1 ind2 inAccumFuncs maxFound
      | ind1 == 20 = maxFound
      | ind2 == 20 = scanForMax4 (ind1 + 1) 0 accumsAndTransforms maxFound
      | otherwise  = scanForMax4 ind1 (ind2 + 1) newAccumsAndTransforms newMax
      where
        (newAccumsAndTransforms, newMax) = scanThroughOneStepOfAccum inAccumFuncs [] maxFound
        scanThroughOneStepOfAccum :: [((Int, Int, Int, Int), Int -> Int -> (Int, Int))] -> 
                                    [((Int, Int, Int, Int), Int -> Int -> (Int, Int))] ->
                                    Int -> ([((Int, Int, Int, Int), Int -> Int -> (Int, Int))], Int)
        scanThroughOneStepOfAccum [] processedAccumsAndTrans mxFound
          = mxFound `seq` (processedAccumsAndTrans, mxFound)
        scanThroughOneStepOfAccum (((s1,s2,s3,s4), func) : xs) processedAccumsAndTrans mxFound
          = mxFound
            `seq` scanThroughOneStepOfAccum xs ((newAccum, func) : processedAccumsAndTrans) newMx
          where
            arrayVal = prob11Array UA.! (newInd1, newInd2)                                   
            (newInd1, newInd2) = func ind1 ind2
            (newAccum, newMx)  = if newInd1 < 0 || newInd1 > 19 || newInd2 < 0 || newInd2 > 19
                                 then ((s1,s2,s3,s4), mxFound)
                                 else ((s2 * arrayVal, s3 * arrayVal, s4 * arrayVal, 1), 
                                      max mxFound (s1 * arrayVal))
    accumsAndTransforms :: [((Int, Int, Int, Int), Int -> Int -> (Int, Int))]
    accumsAndTransforms = 
      [(initAccum, (,)),  -- Horizontal
       (initAccum, \ ind1 ind2 -> (ind2, ind1)),  -- Vertical
       (initAccum, \ ind1 ind2 -> (ind1 + ind2, ind2)), -- Up and to the right from side
       (initAccum, \ ind1 ind2 -> (ind2, ind1 + ind2)), -- Up and to the right from bottom
       (initAccum, \ ind1 ind2 -> (ind2, 19 - (ind1 + ind2))), -- Down and to the right from side
       (initAccum, \ ind1 ind2 -> (ind1 + ind2, 19 - ind2))] -- Down and to the right from the top
    initAccum = (0, 0, 0, 1)
    
-- The sequence of triangle numbers is generated by adding the natural numbers.
-- So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
-- The first ten terms would be:
--    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
--
-- Let us list the factors of the first seven triangle numbers:
--  1: 1
--  3: 1,3
--  6: 1,2,3,6
-- 10: 1,2,5,10
-- 15: 1,3,5,15
-- 21: 1,3,7,21
-- 28: 1,2,4,7,14,28

-- We can see that 28 is the first triangle number to have over five divisors.
-- What is the value of the first triangle number to have over five hundred divisors?

-- The number of factors can be computed from the list of prime factors by taking the
-- count of each prime factor in the list, adding one, and multiplying these together.

prob012 :: PrimeT
prob012 = fst $ head $ dropWhile (\ (_, factCount) -> factCount <= 500)
                   (map numberOfFactors $ tail triangleNumbers)
  where
    numberOfFactors :: PrimeT -> (PrimeT, PrimeT)
    numberOfFactors numb
      = (fromIntegral numb,
          (foldl1' (*) . map (+ 1) . countSames 0 0 . myPrimeFactorsInt) numb)
    countSames :: PrimeT -> PrimeT -> [PrimeT] -> [PrimeT]
    countSames _ 0 [] = []
    countSames _ lastCount [] = [lastCount]
    countSames lastNumb lastCount (x : xs)
      | lastCount `seq` (lastCount == 0) = countSames x 1 xs
      | x == lastNumb = countSames lastNumb (lastCount + 1) xs
      | otherwise = lastCount : countSames x 1 xs           
                    
prob013 :: Integer
prob013 = read $ take 10 (show (result :: Integer))
  where
    result =
          37107287533902102798797998220837590246510135740250+
          46376937677490009712648124896970078050417018260538+
          74324986199524741059474233309513058123726617309629+
          91942213363574161572522430563301811072406154908250+
          23067588207539346171171980310421047513778063246676+
          89261670696623633820136378418383684178734361726757+
          28112879812849979408065481931592621691275889832738+
          44274228917432520321923589422876796487670272189318+
          47451445736001306439091167216856844588711603153276+
          70386486105843025439939619828917593665686757934951+
          62176457141856560629502157223196586755079324193331+
          64906352462741904929101432445813822663347944758178+
          92575867718337217661963751590579239728245598838407+
          58203565325359399008402633568948830189458628227828+
          80181199384826282014278194139940567587151170094390+
          35398664372827112653829987240784473053190104293586+
          86515506006295864861532075273371959191420517255829+
          71693888707715466499115593487603532921714970056938+
          54370070576826684624621495650076471787294438377604+
          53282654108756828443191190634694037855217779295145+
          36123272525000296071075082563815656710885258350721+
          45876576172410976447339110607218265236877223636045+
          17423706905851860660448207621209813287860733969412+
          81142660418086830619328460811191061556940512689692+
          51934325451728388641918047049293215058642563049483+
          62467221648435076201727918039944693004732956340691+
          15732444386908125794514089057706229429197107928209+
          55037687525678773091862540744969844508330393682126+
          18336384825330154686196124348767681297534375946515+
          80386287592878490201521685554828717201219257766954+
          78182833757993103614740356856449095527097864797581+
          16726320100436897842553539920931837441497806860984+
          48403098129077791799088218795327364475675590848030+
          87086987551392711854517078544161852424320693150332+
          59959406895756536782107074926966537676326235447210+
          69793950679652694742597709739166693763042633987085+
          41052684708299085211399427365734116182760315001271+
          65378607361501080857009149939512557028198746004375+
          35829035317434717326932123578154982629742552737307+
          94953759765105305946966067683156574377167401875275+
          88902802571733229619176668713819931811048770190271+
          25267680276078003013678680992525463401061632866526+
          36270218540497705585629946580636237993140746255962+
          24074486908231174977792365466257246923322810917141+
          91430288197103288597806669760892938638285025333403+
          34413065578016127815921815005561868836468420090470+
          23053081172816430487623791969842487255036638784583+
          11487696932154902810424020138335124462181441773470+
          63783299490636259666498587618221225225512486764533+
          67720186971698544312419572409913959008952310058822+
          95548255300263520781532296796249481641953868218774+
          76085327132285723110424803456124867697064507995236+
          37774242535411291684276865538926205024910326572967+
          23701913275725675285653248258265463092207058596522+
          29798860272258331913126375147341994889534765745501+
          18495701454879288984856827726077713721403798879715+
          38298203783031473527721580348144513491373226651381+
          34829543829199918180278916522431027392251122869539+
          40957953066405232632538044100059654939159879593635+
          29746152185502371307642255121183693803580388584903+
          41698116222072977186158236678424689157993532961922+
          62467957194401269043877107275048102390895523597457+
          23189706772547915061505504953922979530901129967519+
          86188088225875314529584099251203829009407770775672+
          11306739708304724483816533873502340845647058077308+
          82959174767140363198008187129011875491310547126581+
          97623331044818386269515456334926366572897563400500+
          42846280183517070527831839425882145521227251250327+
          55121603546981200581762165212827652751691296897789+
          32238195734329339946437501907836945765883352399886+
          75506164965184775180738168837861091527357929701337+
          62177842752192623401942399639168044983993173312731+
          32924185707147349566916674687634660915035914677504+
          99518671430235219628894890102423325116913619626622+
          73267460800591547471830798392868535206946944540724+
          76841822524674417161514036427982273348055556214818+
          97142617910342598647204516893989422179826088076852+
          87783646182799346313767754307809363333018982642090+
          10848802521674670883215120185883543223812876952786+
          71329612474782464538636993009049310363619763878039+
          62184073572399794223406235393808339651327408011116+
          66627891981488087797941876876144230030984490851411+
          60661826293682836764744779239180335110989069790714+
          85786944089552990653640447425576083659976645795096+
          66024396409905389607120198219976047599490197230297+
          64913982680032973156037120041377903785566085089252+
          16730939319872750275468906903707539413042652315011+
          94809377245048795150954100921645863754710598436791+
          78639167021187492431995700641917969777599028300699+
          15368713711936614952811305876380278410754449733078+
          40789923115535562561142322423255033685442488917353+
          44889911501440648020369068063960672322193204149535+
          41503128880339536053299340368006977710650566631954+
          81234880673210146739058568557934581403627822703280+
          82616570773948327592232845941706525094512325230608+
          22918802058777319719839450180888072429661980811197+
          77158542502016545090413245809786882778948721859617+
          72107838435069186155435662884062257473692284509516+
          20849603980134001723930671666823555245252804609722+
          53503534226472524250874054075591789781264330331690

-- I solved this problem back in the summer of 2014, and it's now early 2018. I re-wrote this to use
-- vectors and a simpler and cleaner set of functions. It's not as fast, by about a factor of 2, but
-- is much clearer to view.  It is possible to make the vector larger and then iterate through a
-- list up to the limit so we don't go over the limit when calculating sequences, but it is also
-- more complicated and doesn't save much time.
-- If this is running on a 64-bit machine, there is no need for fromIntegral, but on a 32-bit
-- machine, we need to move back and forth between 32 and 64 bit ints so that we don't overflow
-- when searching forward on collatz values over the limit, but also tieing in with vector indices.

prob014 :: Int
prob014 = snd $ V.ifoldl' accMaxLen (0, 0) collatzVec
  where

    limit = 10 ^ (6 :: Int) :: Int
    limit64 = fromIntegral limit

    -- Accumulate function to find the maximum length in the range.

    accMaxLen acc@(accMxLen, _) index currLen
      | currLen <= accMxLen = acc
      | otherwise = (currLen, index)

    -- The Collatz function, which given a value returns the next in the sequence.

    nextCollatz :: Int64 -> Int64
    nextCollatz val
      | odd val = 3 * val + 1
      | otherwise = val `div` 2

    -- Given a value, return the next Collatz value in the sequence that is less than the limit and
    -- the number of steps to get there. For example, the sequence starting at 13 is: [13, 40, 20,
    -- 10, 5, 16, 8, 4, 2, 1], so if limit is 100, then (nextCollatzWithinLimit 13) is (40, 1), but
    -- if limit is 15, then (nextCollatzWithinLimit 13) is (10, 3).

    nextCollatzWithinLimit :: Int -> (Int, Int)
    nextCollatzWithinLimit val = (firstInRange, stepsToFirstInRange)
      where
        firstInRange = (fromIntegral . head) rest
        stepsToFirstInRange = 1 + length biggerThanLimit
        (biggerThanLimit, rest) = span (>= limit64) (tail collatzSeqStartingWithVal)
        collatzSeqStartingWithVal = iterate nextCollatz (fromIntegral val)

    -- A boxed vector holding Collatz length for each index. The collatzFn used to generate the
    -- value for each element refers back to other elements of this vector, but since the vector
    -- elements are only evaluated as needed and there aren't any loops in the Collatz sequences,
    -- the values are calculated only as needed.

    collatzVec :: V.Vector Int
    collatzVec = V.generate limit collatzFn
      where
        collatzFn :: Int -> Int
        collatzFn index
          | index <= 1 = 1
          | otherwise = (collatzVec V.! nextWithinLimit) + stepsToGetThere
          where
            (nextWithinLimit, stepsToGetThere) = nextCollatzWithinLimit index

-- Well, this one is easy.  It's just another way of thinking about combinations.

prob015 :: Integer
prob015 = comb 40 20

prob016 :: Int
prob016 = digitSum
  where
    digitSum = foldl' (\acc x -> acc + (ord x - ord '0')) 0 answerString
    answerString :: String
    answerString = show ((2 :: Integer)^(1000 :: Integer))
    
prob017 :: Int
prob017 = lengthSum
  where
    lengthSum = foldl1' (+) (map (relevantCharCount . nameOfNumber) [1..1000])
    relevantCharCount :: String -> Int
    relevantCharCount = foldl' (\acc x -> if isLetter x then acc + 1 else acc) 0
    hundredAnd = " hundred and " :: String
    nameOfNumber :: Int -> String
    nameOfNumber 1 = "one"
    nameOfNumber 2 = "two"
    nameOfNumber 3 = "three"
    nameOfNumber 4 = "four"
    nameOfNumber 5 = "five"
    nameOfNumber 6 = "six"
    nameOfNumber 7 = "seven"
    nameOfNumber 8 = "eight"
    nameOfNumber 9 = "nine"
    nameOfNumber 10 = "ten"
    nameOfNumber 11 = "eleven"
    nameOfNumber 12 = "twelve"
    nameOfNumber 13 = "thirteen"
    nameOfNumber 14 = "fourteen"
    nameOfNumber 15 = "fifteen"
    nameOfNumber 16 = "sixteen"
    nameOfNumber 17 = "seventeen"
    nameOfNumber 18 = "eighteen"
    nameOfNumber 19 = "nineteen"
    nameOfNumber 20 = "twenty"
    nameOfNumber 30 = "thirty"
    nameOfNumber 40 = "forty"
    nameOfNumber 50 = "fifty"
    nameOfNumber 60 = "sixty"
    nameOfNumber 70 = "seventy"
    nameOfNumber 80 = "eighty"
    nameOfNumber 90 = "ninety"
    nameOfNumber 100 = "one hundred"
    nameOfNumber 200 = "two hundred"
    nameOfNumber 300 = "three hundred"
    nameOfNumber 400 = "four hundred"
    nameOfNumber 500 = "five hundred"
    nameOfNumber 600 = "six hundred"
    nameOfNumber 700 = "seven hundred"
    nameOfNumber 800 = "eight hundred"
    nameOfNumber 900 = "nine hundred"
    nameOfNumber 1000 = "one thousand"
    nameOfNumber n
      | n < 30  = nameOfNumber 20 ++ nameOfNumber (n - 20)
      | n < 40  = nameOfNumber 30 ++ nameOfNumber (n - 30)
      | n < 50  = nameOfNumber 40 ++ nameOfNumber (n - 40)
      | n < 60  = nameOfNumber 50 ++ nameOfNumber (n - 50)
      | n < 70  = nameOfNumber 60 ++ nameOfNumber (n - 60)
      | n < 80  = nameOfNumber 70 ++ nameOfNumber (n - 70)
      | n < 90  = nameOfNumber 80 ++ nameOfNumber (n - 80)
      | n < 100 = nameOfNumber 90 ++ nameOfNumber (n - 90)
      | n < 200  = "one" ++ hundredAnd ++ nameOfNumber (n - 100)
      | n < 300  = "two" ++ hundredAnd ++ nameOfNumber (n - 200)
      | n < 400  = "three" ++ hundredAnd ++ nameOfNumber (n - 300)
      | n < 500  = "four" ++ hundredAnd ++ nameOfNumber (n - 400)
      | n < 600  = "five" ++ hundredAnd ++ nameOfNumber (n - 500)
      | n < 700  = "six" ++ hundredAnd ++ nameOfNumber (n - 600)
      | n < 800  = "seven" ++ hundredAnd ++ nameOfNumber (n - 700)
      | n < 900  = "eight" ++ hundredAnd ++ nameOfNumber (n - 800)
      | n < 1000 = "nine" ++ hundredAnd ++ nameOfNumber (n - 900)
      | otherwise = "unexpected number for this problem"
                    
maximumPathSum :: String -> IO Int
maximumPathSum inFileName = do 
    fileContents <- BC.readFile inFileName
    let linedFileContents = BC.lines fileContents :: [BC.ByteString]
        wordFileContents  = map BC.words linedFileContents :: [[BC.ByteString]]
        intFileContents   = map convertByteStringsToInts wordFileContents :: [[Int]]
    return (maximum (propagateWeights intFileContents []))
    where
      propagateWeights :: [[Int]] -> [Int] -> [Int]
      propagateWeights [] priorWeights = priorWeights
      propagateWeights (x : xs) [] = propagateWeights xs x
      propagateWeights (x : xs) priorWeights = propagateWeights xs newWeights
        where
          newWeights = map sumMaxAndLast (zip3 (0 : priorWeights) (priorWeights ++ [0]) x)
          sumMaxAndLast (w1, w2, curr) = curr + (if w1 > w2 then w1 else w2)

prob018 :: IO Int
prob018 = maximumPathSum "prob018_in.txt"

data P019Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday |
               Saturday deriving (Eq,Ord,Show)

prob019 :: Int
prob019 = foldl' accumSunday1sts 0 seqOfDayDataTo2001
  where
    seqOfDayDataTo2001 = takeWhile (\(_,_,year) -> year < 2001) seqOfDayDataFrom1901
    seqOfDayDataFrom1901 = dropWhile (\(_,_,year) -> year < 1901) seqOfDayData
    seqOfDayData = zip3 daysOfWeekFrom1900 (datesOfMonth 1900) (infiniteSeqYearsByDay 1900)
    daysOfWeekFrom1900 :: [P019Day]
    daysOfWeekFrom1900 = cycle [Monday, Tuesday, Wednesday, Thursday, 
                                Friday, Saturday, Sunday]
    datesOfMonth :: Int -> [Int]
    datesOfMonth year = [1..31] ++ (if daysInYear year == 366 then [1..29] else [1..28]) ++
                        [1..31] ++ [1..30] ++ [1..31] ++ [1..30] ++ [1..31] ++
                        [1..31] ++ [1..30] ++ [1..31] ++ [1..30] ++ [1..31] ++
                        datesOfMonth (year + 1)
    daysInYear :: Int -> Int
    daysInYear year
      | year `rem` 100 == 0 = if year `rem` 400 == 0 then 366 else 365
      | otherwise = if year `rem` 4 == 0 then 366 else 365
    infiniteSeqYearsByDay :: Int -> [Int]
    infiniteSeqYearsByDay year 
      = replicate (daysInYear year) year ++ infiniteSeqYearsByDay (year + 1)
    accumSunday1sts :: Int -> (P019Day, Int, Int) -> Int
    accumSunday1sts valSoFar (Sunday, 1, _) = valSoFar `seq` (valSoFar + 1)
    accumSunday1sts valSoFar _ = valSoFar

prob020 :: Int
prob020 = digitSum
  where
    digitSum = foldl' (\acc x -> acc + (ord x - ord '0')) 0 answerString
    answerString = show (fact 100) :: String

prob021 :: Int
prob021 = sumOfAmicableNumbers
  where
    upperLimit = 9999
    arrayOfSums = arrayOfProperFactorSumsToLimit upperLimit
    sumOfAmicableNumbers = sumAmicableNumbers 2 0
    sumAmicableNumbers :: Int -> Int -> Int
    sumAmicableNumbers curr sumAmicable
      | curr > upperLimit = sumAmicable
      | val < upperLimit && otherVal == curr && val /= curr
        = sumAmicableNumbers (curr + 1) (sumAmicable + curr)
      | otherwise = sumAmicableNumbers (curr + 1) sumAmicable
      where
        val = arrayOfSums UA.! curr
        otherVal = arrayOfSums UA.! val

type AccValue = (Int, Int)
prob022 :: IO Int
prob022 = do
  fileContents <- BC.readFile "prob022_in.txt"
  let
    (_, value) = foldl' calcValue (1, 0) sortedNames
    sortedNames = sort names
    (names, _, _) = BC.foldl' parseWordsFromString ([], [], False) fileContents
  return value
    where
      baseCharVal = ord 'A' - 1
      calcValue :: AccValue -> BC.ByteString -> AccValue
      calcValue (count, value) name = (count + 1, value + (nameValue * count))
        where
          nameValue = BC.foldl' (\acc x -> acc + ord x - baseCharVal) 0 name

-- This version is surprisingly faster than the vector-based version below.

prob023 :: Int
prob023 = finalSum
  where
    limit = 28123
    limitDiv2 = shiftR limit 1
    abundantNumbers = sort (foldl' (\acc (x,sumPF) -> if x < sumPF then x : acc else acc)
                           [] (listOfProperFactorSumsToLimit limit))
    finalSum = sumNonAbundant arraySums 1 0
    arraySums :: UA.UArray Int Int
    arraySums = UA.array (1, limit) (map (, 1) sumsOfTwoAbundant)
    sumsOfTwoAbundant = outerIter abundantNumbers []
    sumNonAbundant :: UA.UArray Int Int -> Int -> Int -> Int
    sumNonAbundant arr index sm
      | sm `seq` (index >= limit) = sm
      | otherwise = sumNonAbundant arr (index + 1)
                    (if (arr UA.! index) == 1 then sm else sm + index)
    outerIter :: [Int] -> [Int] -> [Int]
    outerIter [] sums = sums
    outerIter (x:xs) sums
      | x > limitDiv2 = sums
      | otherwise = outerIter xs newSums
      where
        newSums = innerIter (x:xs) sums
        innerIter :: [Int] -> [Int] -> [Int]
        innerIter [] sms = sms
        innerIter (y : ys) sms
          | added >= limit = sms
          | otherwise = innerIter ys (added : sms)
          where
            !added = y + x

-- This is a really cool solution that I didn't come up with myself, but now understand.  the "x <-
-- xs" causes x to take all of the values in the list xs, and do the map function for each.

prob024 :: Integer
prob024 = read $ perms "0123456789" !! 999999
  where
    perms [] = [[]]
    perms xs = do
      x <- xs
      map (x:) (perms $ delete x xs)

prob025 :: Int
prob025 = fromJust (findIndex (\x -> x >= 10 ^ (999 :: Int)) myFibNumbersInteger)

prob026 :: Int
prob026 = fst $ foldl' findMaxCycle (0,0) (map repeatsInReciprocal [2..999])
  where
    findMaxCycle :: (Int, Int) -> RepeatsRecipT -> (Int, Int)
    findMaxCycle (maxSoFar, maxCycle) (newVal, _, newCycle, _)
      = if newCycle > maxCycle then (newVal, newCycle) else (maxSoFar, maxCycle)

prob027 :: Int
prob027 = fst maxPrimes
  where
    maxPrimes = foldl1' (\(prodAcc, countAcc) (prod, count) ->
                          if count > countAcc
                          then (prod, count)
                          else (prodAcc, countAcc))
                        primeQuadraticResults
    primeQuadraticResults =
        map (\(a, b) -> (a * b, numberOfPrimesSeq a b)) validABPairs
    validABPairs = [(a, b) | a <- possibleAVals, b <- possibleBValsPos,
                             a >= 0 || ((- a) < b)]
    possibleAVals = [-999..999]
    possibleBValsPos = takeWhile (< 1000) myPrimes
    computeQuadraticResult :: Int -> Int -> Int -> Int
    computeQuadraticResult a b n = n ^ (2 :: Int) + (a*n) + b
    numberOfPrimesSeq :: Int -> Int -> Int
    numberOfPrimesSeq a b = length $ takeWhile
      (isPrime . fromIntegral . computeQuadraticResult a b) [1..]

prob028 :: Int64
prob028 = diagDownRight + diagUpRight - 1
  where
    sizeOfSquare = 1001
    diagDownRight = sum $ tail $ scanl (+) 1
      (take sizeOfSquare [x*2 | x <- [0..]])
    diagUpRight = sum $ tail $ scanl (+) 1
      (take sizeOfSquare (map (\x -> 2 * if odd x then x - 1 else x) [1..]))

prob029 :: Int
prob029 = length $ map head (group $ sort listOfPowers)
  where
    listOfPowers :: [Integer]
    listOfPowers = [x ^ (y :: Int) | x <- [2..100], y <- [2..100]]

prob030 :: Int
prob030 = sum $ filter sumOfDigitPowersIsSame [10..295277]
  where
    sumOfDigitPowersIsSame :: Int -> Bool
    sumOfDigitPowersIsSame value = sumOfDigitPowers == value
      where
        sumOfDigitPowers = foldl' (\acc x -> acc + (ord x - ord '0') ^ (5 :: Int)) 0 strValue
        strValue = show value

prob031 :: Int
prob031 = changePermutations [200, 100, 50, 20, 10, 5, 2, 1] 200
  where
    changePermutations :: [Int] -> Int -> Int
    changePermutations _ 0 = 1
    changePermutations [] _ = 0 
    changePermutations (c:cs) valLeft
      | c > valLeft = furtherCombosWithoutThisCoin
      | otherwise = furtherCombosWithThisCoin + furtherCombosWithoutThisCoin
      where
        furtherCombosWithoutThisCoin = changePermutations cs valLeft
        furtherCombosWithThisCoin = changePermutations (c:cs) newValLeft
        newValLeft = valLeft - c

-- It has to be a for digit number for the multiplicand.

prob032 :: Int
prob032 = sum justProductsWithoutDups
  where
    justProductsWithoutDups = removeDups [] justProducts
    justProducts = map (\(x,_,_) -> x) filteredPerms
    filteredPerms = filter (\(x,y,z) -> x == y * z) (expandAllPerms length4Partitions)
    length4Partitions = partitionsOfLength "123456789" 4
    expandAllPerms :: [(String,String)] -> [(Int,Int,Int)]
    expandAllPerms [] = []
    expandAllPerms ((p1s,p2s):xs) = [(x,y,z) | x <- permsThenInts p1s,
                                     (y,z) <- allPerms allSummandPartitions]
                                     ++ expandAllPerms xs
      where
        allPerms :: [(String,String)] -> [(Int,Int)]
        allPerms [] = []
        allPerms ((p1s',p2s'):xs') = [(x,y) | x <- permsThenInts p1s', y <- permsThenInts p2s']
                                      ++ allPerms xs'
        permsThenInts :: String -> [Int]
        permsThenInts str = map stringToInt (permutations str)

        -- We know that the multiplicands have 5 digits together, and so we just need the ones where
        -- the first has 1 or 2.  If we chose 3 and 4, we would just repeats.

        allSummandPartitions = partitionsOfLengths p2s 1 2
        partitionsOfLengths :: [a] -> Int -> Int -> [([a],[a])]
        partitionsOfLengths ys n m
          | n > m = []
          | otherwise = partitionsOfLength ys n ++ partitionsOfLengths ys (n+1) m
    
 
prob033 :: Int
prob033 = snd multPair `div` gcd (snd multPair) (fst multPair)
  where
    multPair :: (Int,Int)
    multPair = foldl1' (\(resN,resD) (n,d) -> (resN*n, resD*d)) numerDenomPairs
    numerDenomPairs :: [(Int,Int)]
    numerDenomPairs = [(x, z) | x <- [1..9], y <- [1..9], z <- [1..9],
                                x /= z, 10*x*z + y*z == 10*y*x + x*z]

prob034 :: Int
prob034 = sum $ filter isDigitFactorialEqual [10..1814402]
  where
    vecFactorials :: UV.Vector Int
    vecFactorials = UV.fromList
                    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    isDigitFactorialEqual :: Int -> Bool
    isDigitFactorialEqual value =
      sum (map (\x -> vecFactorials UV.! (ord x - ord '0'))
               (show value)) == value

prob035 :: Int
prob035 = length $ filter allRotationsPrime $ takeWhile (< 1000000) myPrimes
  where
    allRotationsPrime :: Int -> Bool
    allRotationsPrime value = possiblyAllRotationsPrime valStr digitCount
                              && allPrime (otherRotations valStr digitCount)
      where
        !valStr = show value
        !digitCount = length valStr

    -- All numbers where all rotations are prime and where they have 2 digits or more, all digits
    -- must be 1,3,7,9.  Testing this before doing the rotations saves a lot of time.

    possiblyAllRotationsPrime :: String -> Int -> Bool
    possiblyAllRotationsPrime _ 1 = True
    possiblyAllRotationsPrime valStr _ = allPrimeEndingDigits valStr
     where
       allPrimeEndingDigits :: String -> Bool
       allPrimeEndingDigits [] = True
       allPrimeEndingDigits ('1':xs) = allPrimeEndingDigits xs
       allPrimeEndingDigits ('3':xs) = allPrimeEndingDigits xs
       allPrimeEndingDigits ('7':xs) = allPrimeEndingDigits xs
       allPrimeEndingDigits ('9':xs) = allPrimeEndingDigits xs
       allPrimeEndingDigits _ = False

    -- The allPrime function tests for the number being odd before calling isPrime.  Note that this
    -- wouldn't work for 2, but in the case of 2, there will be no other rotations, so it will never
    -- be tested.

    allPrime :: [Int] -> Bool
    allPrime [] = True
    allPrime (x:xs)
      | (x .&. 1 == 1) && isPrime x = allPrime xs
      | otherwise = False

    -- Generate a list of all of the rotations.  Note that we don't need the first one, as we
    -- already know it is prime.

    otherRotations :: String -> Int -> [Int]
    otherRotations valStr digitCount
      = otherRotations' (digitCount - 1) (tail (valStr ++ valStr))
      where
        otherRotations' :: Int -> String -> [Int]
        otherRotations' 0 _ = []
        otherRotations' count str =
          let currRotation = read (take digitCount str)
              decCount = count - 1
          in currRotation : otherRotations' decCount (tail str)

prob036 :: Int
prob036 = sum $ filter palindromicInBases10And2 [1..999999]
  where
    palindromicInBases10And2 :: Int -> Bool
    palindromicInBases10And2 value = palindromicStr (show value)
                                     && palindromicStr (show2r value)
    palindromicStr :: String -> Bool
    palindromicStr str = str == reverse str
    show2r :: Int -> String  -- This reverses the string, which is okay here.
    show2r 0 = []
    show2r value = (if value .&. 1 == 1 then '1' else '0') : show2r (value `shiftR` 1)

-- It turns out that this is just as fast without the firstPassFilter, probably because of the
-- divisions needed to convert the number to a string.  Still, I like the textual filter, so I left
-- it in.

prob037 :: Int
prob037 = sum . take 11 . filter allPrefixSuffixArePrime . map read
              . filter firstPassFilter . map show $ drop 4 myPrimes
  where

    -- Remove primes containing digits that will prevent the truncated numbers to be primes.  The
    -- first digit must be prime, but can be 2 or 5.  The rest of the digits can't be even or 5.
    -- The last digit must be either 3 or 7.

    firstPassFilter :: String -> Bool
    firstPassFilter [] = error "Null list in firstPassFilter."
    firstPassFilter (x:xs)
      | x `notElem` ['2','3','5','7'] = False
      | any (\y -> y `notElem` ['1','3','7','9']) (init xs) = False
      | last xs `notElem` ['3','7'] = False
      | otherwise = True
    allPrefixSuffixArePrime :: Int -> Bool
    allPrefixSuffixArePrime value = all isPrime (allPrefixSuffix value)

    -- Generate all prefix and suffix number of the given number.  For example, 345 would generate
    -- [3,45,34,5].

    allPrefixSuffix :: Int -> [Int]
    allPrefixSuffix value = aPS 10 []
      where
        aPS :: Int -> [Int] -> [Int]
        aPS tenPower results
          | quotValue == 0 = results
          | otherwise = aPS (tenPower * 10) (quotValue : remValue : results)
          where
            quotValue = value `quot` tenPower
            remValue  = value `rem` tenPower

-- This doesn't work as cleanly as the C++ version because the permutations aren't generated in a
-- very predictable order, and so we can't just look for the first answer.  Assume there is an
-- answer starting with a 9, which we were told in the problem.

prob038 :: Int
prob038 = result
  where
    (result,_,_) = foldl' biggestPandigitSum (0,0,0)
                   (map (9:) (permutations digitsToUse))
    digitsToUse = [8,7,6,5,4,3,2,1]
    lengthOfAllDigits = length digitsToUse + 1
    biggestPandigitSum :: (Int,Int,Int) -> [Int] -> (Int,Int,Int)
    biggestPandigitSum (value,first,second) digits
      | firstInputDigit < first
        || (firstInputDigit == first && secondInputDigit < second)
        = (value,first,second)
      | otherwise = if pandigitSum > value
                    then (pandigitSum,head digits, head (tail digits))
                    else (value,first,second)
      where
        pandigitSum = pandigitalSumAny digits
        firstInputDigit = head digits
        secondInputDigit = head (tail digits)
    listOfIntsToInt :: [Int] -> Int -> Int -> Int
    listOfIntsToInt _ 0 val = val
    listOfIntsToInt [] _ _ = error "Null list in listOfIntsToInt"
    listOfIntsToInt (x:xs) toTake val
      = listOfIntsToInt xs (toTake - 1) (val * 10 + x)
    pandigitalSumAny :: [Int] -> Int
    pandigitalSumAny digits
      | pandigitalSum digits 1 lengthOfAllDigits
        || pandigitalSum digits 2 lengthOfAllDigits
        || pandigitalSum digits 3 lengthOfAllDigits
        || pandigitalSum digits 4 lengthOfAllDigits
        = listOfIntsToInt digits lengthOfAllDigits 0
      | otherwise = 0
    pandigitalSum :: [Int] -> Int -> Int -> Bool
    pandigitalSum digits lengthFirst totalLength
      = checkRestForMatch (drop lengthFirst digits) 2
                          (totalLength - lengthFirst)
      where
        baseVal = listOfIntsToInt digits lengthFirst 0
        checkRestForMatch :: [Int] -> Int -> Int -> Bool
        checkRestForMatch [] _ _ = True
        checkRestForMatch digts currFactor remainingLength
          | expectedListLen > remainingLength = False
          | expectedList /= take expectedListLen digts = False
          | otherwise = checkRestForMatch (drop expectedListLen digts)
                        (currFactor + 1) (remainingLength - expectedListLen)
          where
            !expectedValue = baseVal * currFactor
            !expectedList = intToListOfInts expectedValue
            !expectedListLen = length expectedList

prob039 :: Int
prob039 = result
  where
    maxSearchSum = 1000
    (_, result, _) = UV.foldl' findIndexOfMaxCount (0, 0, 0) sumCount
    findIndexOfMaxCount :: (Int, Int, Int) -> Int -> (Int, Int, Int)
    findIndexOfMaxCount (indexCurr, indexMax, countMax) x
      = if x > countMax then (indexCurr+1, indexCurr, x) else (indexCurr+1, indexMax, countMax)
    sumCount :: UV.Vector Int
    sumCount = UV.accum (+) (UV.replicate (maxSearchSum+1) 0) tripleSumsWithOne
    tripleSumsWithOne :: [(Int,Int)]
    tripleSumsWithOne = map (\(a,b,c) -> (a+b+c,1)) triplesInRange
    triplesInRange :: [(Int, Int, Int)]
    triplesInRange = pythagoreanTriplesPrimTree (ptptWithinLimitPerimeter maxSearchSum)

prob040 :: Int
prob040 = prodDigits champernowne'sConstant 1 [1, 10, 100, 1000, 10000, 100000, 1000000] 1
  where
    champernowne'sConstant = listDigits [1..] []
    listDigits :: [Int] -> String -> String
    listDigits [] _ = []
    listDigits (x:xs) [] = listDigits xs (show x)
    listDigits xs (d:ds) = d : listDigits xs ds
    prodDigits :: String -> Int -> [Int] -> Int -> Int
    prodDigits [] _ _ _ = error "String null in prodDigits."
    prodDigits _ _ [] prodSoFar = prodSoFar
    prodDigits (x:xs) count (d:ds) prodSoFar
      | count == d = prodDigits xs (count+1) ds (prodSoFar * (ord x - ord '0'))
      | otherwise = prodDigits xs (count+1) (d:ds) prodSoFar

-- Aha!  We only have to check primes up to 7654321 because eight or nine digit pandigit primes will
-- all be divisible by 3 since the sum of their digits is divisible by three.
-- Also, generating permutations of the digits from 1 to 7 and checking primality is much faster
-- than checking all of the primes for pandigits (see prob_041a).
 
prob041 :: Int
prob041 = maximum $ filter isPrime $ map stringToInt (permutations "7654321")

prob042 :: IO Int
prob042 = do
  fileContents <- BC.readFile "prob042_in.txt"
  let
    value = foldl' countTriangleWords 0 names
    (names, _, _) = BC.foldl' parseWordsFromString ([], [], False) fileContents
  return value
    where
      triangleNumbersV :: UV.Vector Bool
      triangleNumbersV = UV.replicate 512 False UV.// triangleNumberList
      isTriangleNumber :: Int -> Bool
      isTriangleNumber value = triangleNumbersV UV.! value
      triangleNumberList :: [(Int, Bool)]
      triangleNumberList = zip (takeWhile (< 512) triangleNumbers) (repeat True)
      baseCharVal = ord 'A' - 1
      countTriangleWords :: Int -> BC.ByteString -> Int
      countTriangleWords count word
        | isTriangleNumber wordValue = count + 1
        | otherwise = count
        where
          wordValue = BC.foldl' (\acc x -> acc + ord x - baseCharVal) 0 word

prob043 :: Int64
prob043 = sum (pandigWithProperty [0..9] [17, 13, 11, 7, 5, 3, 2] 0 0 0 1 0 [])
  where

    -- This function will perform a depth first search for solutions.  Processing is done growing
    -- the result from right to left so that the search tree can be pruned early due to three-digit
    -- numbers not divisible by 17.  It is called with the digits remaining to use; primes remaining
    -- to divide by; three accumulators that are used to keep track of the current three-digit
    -- number to test for divisibility by the current prime, and those that will grow into that
    -- number; a power of ten that indicates the digit in the result we are currently processing;
    -- the number we have accumulated so far; and the list of numbers that work for this problem so
    -- far in the search.  Here is a trace of this function running with a carefully chosen digit
    -- order to show two solutions being found with minimal back-tracking:
    --
    -- pdwp [8,7,3,1,0,6,4,5,2,9]  [17,13,11,7,5,3,2]  0  0  0  1  0  []
    -- pdwp [2,5,4,6,0,1,3,7,8]  [17,13,11,7,5,3,2]  9  90  900  10  9  []
    -- pdwp [7,3,1,0,6,4,5,2]  [17,13,11,7,5,3,2]  8  89  890  100  89  []
    -- pdwp [5,4,6,0,1,3,7]  [17,13,11,7,5,3,2]  2  28  289  1000  289  []
    -- pdwp [3,1,0,6,4,5]  [13,11,7,5,3,2]  7  72  728  10000  7289  []
    -- pdwp [4,6,0,1,3]  [11,7,5,3,2]  5  57  572  100000  57289  []
    -- pdwp [1,0,6,4]  [7,5,3,2]  3  35  357  1000000  357289  []
    -- pdwp [6,0,1]  [5,3,2]  4  43  435  10000000  4357289  []
    -- pdwp [0,6]  [3,2]  1  14  143  100000000  14357289  []
    -- pdwp [6,1]  [3,2]  0  4  43  100000000  4357289  []
    -- pdwp [0,1]  [3,2]  6  64  643  100000000  64357289  []
    -- pdwp [0,1,4]  [5,3,2]  6  63  635  10000000  6357289  []
    -- pdwp [1,0]  [3,2]  4  46  463  100000000  46357289  []
    -- pdwp [0,4]  [3,2]  1  16  163  100000000  16357289  []
    -- pdwp [1,4]  [3,2]  0  6  63  100000000  6357289  []
    -- pdwp [1]  [2]  4  40  406  1000000000  406357289  []
    -- pdwp []  []  1  14  140  10000000000  1406357289  []
    -- pdwp [4]  [2]  1  10  106  1000000000  106357289  [1406357289]
    -- pdwp []  []  4  41  410  10000000000  4106357289  [1406357289]
    -- pdwp [1,6,4]  [5,3,2]  0  3  35  10000000  357289  [4106357289,1406357289]    

    pandigWithProperty :: [Int] -> [Int] -> Int -> Int -> Int -> Int64 -> Int64
                                -> [Int64] -> [Int64]

    -- If there are no more primes to divide by, we have come to a solution, so append it to the
    -- solutions found so far.

    pandigWithProperty _ [] _ _ _ _ currNum currResult = currNum : currResult
    pandigWithProperty digits (dp : dps) acc1 acc2 acc3 placeFactor
                       currNum currResult

      -- If we haven't seen three digits yet, we can't yet prune by dividing by a prime.  Try all
      -- digits for the next one.

      | placeFactor <= 100
        = foldl' (pandigWithPropertyAndDigit (dp : dps))
                 currResult allPairsFirstAndRestList

      -- If the current three-digit accumulator is divisible by the current prime, then we can
      -- continue the search to the next digit.  Fold over all digit choices.

      | acc3 `rem` dp == 0
        = foldl' (pandigWithPropertyAndDigit dps)
                 currResult allPairsFirstAndRestList

      -- If we are past the first three digits and the current three-digit accumulator isn't
      -- divisible by the current prime, then there are no solutions past this point in the search,
      -- so just return the solutions we were passed.

      | otherwise = currResult
      where

        -- Generate a list of pairs holding each digit left to use and a list of the remaining
        -- digits other than that one.  For example: allPairsFirstAndRest [1,2,3] =
        -- [(3,[2,1]),(2,[1,3]),(1,[2,3])]

        allPairsFirstAndRestList = allPairsFirstAndRest digits

        -- This function will call the search on the next level of the search tree.  The accumulator
        -- is just the list of answers so far, and the current element is a pair with an available
        -- digit and a list of the other available digits.

        pandigWithPropertyAndDigit :: [Int] -> [Int64] -> (Int, [Int])
                                   -> [Int64]
        pandigWithPropertyAndDigit divPrimes currRes (d, ds)
          = pandigWithProperty ds divPrimes newAcc1 newAcc2 newAcc3
             (placeFactor * 10) (currNum + fromIntegral d * placeFactor)
             currRes
          where

            -- Update the accumulators for the next level of the search.  As we progress downward in
            -- the search, acc3 is built up from the prior two accumulators.

            newAcc1 = d
            newAcc2 = acc1 + 10 * d
            newAcc3 = acc2 + 100 * d
                                 
type PentPairT = (Int64, Int64)

prob044 :: Int64
prob044 = p44 (1, 4) (1, 4) (1, 4) (1, 4) (1, 4) (maxBound :: Int64)
  where

    -- Progress through the Pentagonal numbers, pn, looking at all possible options for pk, pj, and
    -- pm = pk - pj where pk + pj = pn.  As we move through larger values of pn, the minimum values
    -- of pk, pj, and pm we need to consider increase, so at each instantiation of p44', the lists
    -- passed have the minimum possible values at the head.  This greatly reduces the searching
    -- needed.

    p44 :: PentPairT -> PentPairT -> PentPairT -> PentPairT
            -> PentPairT -> Int64 -> Int64
    p44 (pn, pnInc) (pk, pkInc) (pkMax, pkMaxInc) (pj, pjInc)
        (pmMax, pmMaxInc) best

      -- When the last increment for the top of list of pk numbers is greater than the best pm we
      -- have found, no more smaller pm values are possible, so we are done.  Return the best pm
      -- found.

      | (pkInc - 3) >= best = best

      -- Compute drop from the front of the pk, pj, and pm lists those numbers that won't be useful
      -- for the current value of pn.  Then try all possible combinations for pk, pj, and pm where
      -- pk + pj = pn and pm = pk - pj.  Pass the lowest value of pm found, or more likely the pm
      -- value passed in as best.

      | otherwise = p44 (nextPn, nextPnInc) (nextPk, nextPkInc)
                        (nextPkMax, nextPkMaxInc) (nextPj, nextPjInc)
                        (nextPmMax, nextPmMaxInc) newBest

      where

        -- In the next iteration, just go to the next Pn.
        
        !nextPn = pn + pnInc
        !nextPnInc = pnInc + 3

        -- The smallest Pk for the next iteration is the first Pentagonal number greater than half
        -- the next Pn.  This is used to determine if we are finished with the search, as when the
        -- increment for this number is greater than the smallest Pm found so far, no smaller
        -- solutions are possible.

        (nextPk, nextPkInc) = incUntilGE (pk, pkInc) (shiftR nextPn 1 + 1)

        -- The maximum pk to use in the search for the next iteration depends on whether we have
        -- found any solutions or not.  If we haven't, then it's just the prior Pn value, as there
        -- could be a Pj that is equal to the next increment from Pn.  If we have found a solution,
        -- then we're only interested in smaller ones, so that limits the largest Pk to the (nextPn
        -- - newBest) / 2.  If the best value hasn't changed in the last iteration, we can iterate
        -- up from the current max Pk, but if it has changed, then start at the lowest pk and
        -- iterate up until finding it.
                               
        !(nextPkMax, nextPkMaxInc)
          = if newBest == (maxBound :: Int64)
            then (pn, pnInc)
            else incUntilLastLT (if newBest == best
                                 then (pkMax, pkMaxInc)
                                 else (pk, pkInc))
                                (shiftR (nextPn + newBest) 1)

        -- Here we calculate, for the next iteration, the lowest Pj that could pair with a Pk for a
        -- solution.  If no solutions have been found yet, then the smallest Pj could be is the the
        -- next Pn increment.  If a solution has been found (and we're only interested in finding
        -- smaller ones), then the smallest Pj could be is (nextPn - bestSolution) / 2.

        !nextPjLimit = if newBest < nextPn
                       then max pnInc (shiftR (nextPn - newBest) 1)
                       else pnInc
        !(nextPj, nextPjInc) = incUntilGE (pj, pjInc) nextPjLimit

        -- For the next iteration, the maximum Pm limit is the maximum Pk value minus the minimum Pj
        -- value if we haven't found a solution yet.  If we have, then the maximumPm value is the
        -- prior best solution.  Note that when the best value changes we start all the way at the
        -- start of the sequence to find nextPmMax.  This is a rare case, and I tried decrementing
        -- from the current pmMax, and it was slower.

        !(nextPmMax, nextPmMaxInc)
          | newBest == (maxBound :: Int64) = incUntilLastLE (pmMax, pmMaxInc) (nextPkMax - nextPj)
          | newBest == best = (pmMax, pmMaxInc)
          | otherwise = incUntilLastLT (1, 4) newBest

        newBest = tryCombosForThisPn (pkMax, pkMaxInc - 3)
                                      (pj, pjInc)
                                      (pmMax, pmMaxInc - 3) best

        -- Return the Pentagonal pair just before reaching greater than the limit.

        incUntilLastLE :: PentPairT -> Int64 -> PentPairT
        incUntilLastLE (val, inc) limit
          | newVal > limit = (val, inc)
          | otherwise = incUntilLastLE (newVal, newInc) limit
          where
            !newVal = val + inc
            !newInc = inc + 3

        -- Return the Pentagonal pair just before reaching greater than or equal the limit.

        incUntilLastLT :: PentPairT -> Int64 -> PentPairT
        incUntilLastLT (val, inc) limit
          | newVal >= limit = (val, inc)
          | otherwise = incUntilLastLT (newVal, newInc) limit
          where
            !newVal = val + inc
            !newInc = inc + 3

        -- Return the first Pentagonal pair that is greater than or equal to the limit.

        incUntilGE :: PentPairT -> Int64 -> PentPairT
        incUntilGE (val, inc) limit
          | val >= limit = (val, inc)
          | otherwise = incUntilGE (newVal, newInc) limit
          where
            !newVal = val + inc
            !newInc = inc + 3

        -- This function is passed the highest Pk and lowest Pj to try to find solutions with the
        -- current Pn.  It is also passed the maximum Pm that could work with the other values.  The
        -- idea is to decrement Pk and increment Pj appropriately to find any possible pairs that
        -- add up to Pn.  When this is found, see if Pk - Pj is also a Pentagonal number by working
        -- down from the maximum Pm value passed in.  When we check a possible solution by walking
        -- down Pm values, save where we stopped for the start the next time because the difference
        -- between Pk and Pj will be smaller each try.  Either return the solution passed in or if
        -- one is found, return it.

        tryCombosForThisPn :: PentPairT -> PentPairT -> PentPairT
                              -> Int64 -> Int64
        tryCombosForThisPn (pk', pkDec') (pj', pjInc') (pm', pmDec') inBest
          | pk' < pk = inBest
          | pkpjSum < pn
            = tryCombosForThisPn (pk', pkDec') nxtPj (pm', pmDec') inBest
          | pkpjSum > pn
            = tryCombosForThisPn nxtPk (pj', pjInc') (pm', pmDec') inBest
          | otherwise = tryCombosForThisPn nxtPk nxtPj (newPm, newPmDec)
                          (if isPent then pkpjDiff else inBest)
          where
            !pkpjSum  = pk' + pj'
            !nxtPk = (pk' - pkDec', pkDec' - 3)
            !nxtPj = (pj' + pjInc', pjInc' + 3)
            pkpjDiff = pk' - pj'
            (isPent, newPm, newPmDec) = isPentagonal (pm', pmDec') pkpjDiff

            -- Search down the sequence from val for the number to check.  Return whether it is
            -- found along with the values we stopped searching at for continuation later.
                                        
            isPentagonal :: PentPairT -> Int64 -> (Bool, Int64, Int64)
            isPentagonal (val, valDec) toCheck
              | val < toCheck = (False, val, valDec)
              | val == toCheck = (True, newVal, newValDec)
              | otherwise = isPentagonal (newVal, newValDec) toCheck
              where
                newVal = val - valDec
                newValDec = valDec - 3

-- I didn't realize until finishing this problem and looking at other people's solutions that you
-- can entirely ignore the triangle numbers since all hexagonal numbers are triangle numbers.  It
-- would be a little faster to leave them out of consideration, but the computation is quite fast
-- anyway.

prob045 :: Int
prob045 = result
  where
    (result, _, _, _) = head $ filter (\(val,_,_,_) -> val > 40755)
                             $ findEqualTriplets (zip triangleNumbers [1..])
                                                 (zip pentagonalNumbers [1..])
                                                 (zip hexagonalNumbers [1..])
    findEqualTriplets :: [(Int, Int)] -> [(Int, Int)] -> [(Int, Int)] -> [(Int, Int, Int, Int)]
    findEqualTriplets [] _ _ = error "Null tc list in findEqualTriplets."
    findEqualTriplets _ [] _ = error "Null pc list in findEqualTriplets."
    findEqualTriplets _ _ [] = error "Null hc list in findEqualTriplets."
    findEqualTriplets allT@((t,tc):ts) allP@((p,pc):ps) allH@((h,hc):hs)
      | p == h && h == t = (t,tc,pc,hc) : findEqualTriplets ts ps hs
      | h > p = findEqualTriplets allT ps allH
      | p > h = findEqualTriplets allT allP hs
      | h > t = findEqualTriplets ts allP allH
      | otherwise = findEqualTriplets allT allP hs 

prob046 :: Int
prob046 = head (removeElementsSorted listOfAllPrimesPlusTwiceAllSquares oddComposites)
  where
    listOfAllPrimesPlusTwiceAllSquares = listOfAllPrimesPlusTwiceAllSquaresF
      (HP.singleton (head (head listOfAllPrimeSeries), tail (head listOfAllPrimeSeries)))
      (tail listOfAllPrimeSeries)
    listOfAllPrimesPlusTwiceAllSquaresF :: HP.MinPrioHeap Int [Int] -> [[Int]] -> [Int]
    listOfAllPrimesPlusTwiceAllSquaresF heap listOfSubLists
      | heapHeadPriority < listFirstVal = heapHeadPriority
        : listOfAllPrimesPlusTwiceAllSquaresF
            (HP.insert newHeadJustPopped heapWithTopRemoved) listOfSubLists
      | heapHeadPriority == listFirstVal = listOfAllPrimesPlusTwiceAllSquaresF
            (HP.insert newHeadJustPopped heapWithTopRemoved) listOfSubLists
      | otherwise = listOfAllPrimesPlusTwiceAllSquaresF
            (HP.insert newHeadNewList heap) (tail listOfSubLists)
      where
        newHeadJustPopped = (head heapHeadList, tail heapHeadList)
        newHeadNewList = (head (head listOfSubLists), tail (head listOfSubLists))
        (heapHeadPriority, heapHeadList) = fromJust (HP.viewHead heap)
        heapWithTopRemoved = fromJust (HP.viewTail heap)
        listFirstVal = head (head listOfSubLists)
    -- This is the list of odd composite numbers.
    oddComposites = removeElementsSorted myPrimes [3,5..]

    listOfAllPrimeSeries :: [[Int]]
    listOfAllPrimeSeries = map listOfThisPrimePlusTwiceAllSquares myPrimes
    listOfThisPrimePlusTwiceAllSquares :: Int -> [Int]
    listOfThisPrimePlusTwiceAllSquares prime = [prime + 2 * (x * x) | x <- [1..]]

prob047 :: Int
prob047 = firstFour (fromIntegral startPoint) uniqueFactorCounts
  where
    startPoint = 2
    uniqueFactorCounts = map (countUniqueInSortedList . myPrimeFactorsInt) [startPoint..]
    firstFour :: Int -> [Int] -> Int
    firstFour _ [] = error "Fewer than four in list for firstFour."
    firstFour _ [_] = error "Fewer than four in list for firstFour."
    firstFour _ [_, _] = error "Fewer than four in list for firstFour."
    firstFour _ [_, _, _] = error "Fewer than four in list for firstFour."
    firstFour count (w : x : y : z : rest)
        | z /= 4 = firstFour (count + 4) rest
        | y /= 4 = firstFour (count + 3) (z : rest)
        | x /= 4 = firstFour (count + 2) (y : z : rest)
        | w /= 4 = firstFour (count + 1) (x : y : z : rest)
        | otherwise = count

prob048 :: Integer
prob048 = read $ reverse $ take 10 $ reverse $ show $ sum $ map selfPower [1..1000]
  where
    selfPower :: Integer -> Integer
    selfPower val = val^val

data P49DiffVals = P49DiffVals Int Int Int deriving (Show)
instance Eq P49DiffVals where
  (P49DiffVals diff1 _ _) == (P49DiffVals diff2 _ _) = diff1 == diff2
instance Ord P49DiffVals where
  compare (P49DiffVals diff1 val1 _) (P49DiffVals diff2 val2 _)
    = if diff1 == diff2 then compare val1 val2 else compare diff1 diff2

prob049 :: Int64
prob049 = result
  where
    result = extractSolution justLongOnes

    -- A list of list of lists where the inner list contains two P49DiffVals with the same
    -- difference, and where val 2 of the first is equal to val1 of the second.  Also, no numbers
    -- are less than 1000, and we have filtered out the solution noted in the problem.

    justLongOnes
      = filter (not . null) $
        map (filter linkedDiffs . filter (\x -> length x == 2) . group . sort . allDiffs)
            allRelatedPrimes

    -- A list of lists where the inner lists are all related primes having the same digits.  These
    -- inner lists will be sorted.

    allRelatedPrimes :: [[Int]]
    allRelatedPrimes = map permPrimes moreThanTwoPrimePerms

    -- The smallest permutation number where more than two of the permutations of these digits are
    -- primes.

    moreThanTwoPrimePerms :: [Int]
    moreThanTwoPrimePerms = map head $ filter (\x -> length x >= 3) (group sortedDigitOrder)

    -- A list of the smallest numbers that are a permutation the digits of the four-digit primes,
    -- which is not necessarily a prime itself, but will allow us to see which primes are related in
    -- terms of having the same digits.

    sortedDigitOrder :: [Int]
    sortedDigitOrder = (sort . map (read . sort . show)) fourDigitPrimes

    -- A list of all four-digit primes.

    fourDigitPrimes = takeWhile (< 10000) $ dropWhile (< 1000) myPrimes

    -- Insure that there is a single solution, and return the 12 concatenated digits from the three
    -- primes

    extractSolution :: [[[P49DiffVals]]] -> Int64
    extractSolution xs = if length xs /= 1 then 0 else innerExtract
      where
        innerExtract = if length hxs /= 1 then 0 else innerInnerExtract
        hxs = head xs
        hhxs = head hxs
        P49DiffVals da1 va1 va2 = head hhxs
        P49DiffVals db1 _ vb2 = head (tail hhxs)
        innerInnerExtract = if length hhxs /= 2 then 0 else pairExtract
        pairExtract = fromIntegral va1 * 100000000 + fromIntegral va2 * 10000 + fromIntegral vb2

    -- Used to filter out pairs where the second value of the first isn't equal to the first value
    -- of the second.  Also filter out values where the smallest number is less than 1000 and the
    -- answer we're not supposed to find.

    linkedDiffs :: [P49DiffVals] -> Bool
    linkedDiffs [P49DiffVals diff1 v1 value1, P49DiffVals _ value2 _]
      | diff1 == 3330 && v1 == 1487 = False
      | v1 < 1000 = False
      | value1 == value2 = True
      | otherwise = False
    linkedDiffs _ = False

    -- Generate a list of P49DiffVals representing all of the differences between the integers in
    -- the incoming list.

    allDiffs :: [Int] -> [P49DiffVals]
    allDiffs [] = []
    allDiffs (x : xs) = map (diffFn x) xs ++ allDiffs xs
      where
        diffFn :: Int -> Int -> P49DiffVals
        diffFn val1 val2 = P49DiffVals (val2 - val1) val1 val2

    -- This function takes in a number between 100 and 9999, and will generate all primes that are
    -- made up of a permutation of these digits.  Note that we remove duplicates because of possible
    -- repeated digits.

    permPrimes :: Int -> [Int]
    permPrimes value = sortedPrimes
      where
        sortedPrimes = sort $ filter isPrime permsNoDups
        permsNoDups = removeDups [] $ sort $ map read perms
        !perms = permutations fourDigitExpand
        !fourDigitExpand = if value < 1000 then '0' : expandedNumber else expandedNumber
        expandedNumber = show value

-- This is a cool algorithm.  The idea is to work through the primes, creating for each one an entry
-- in a list.  For each of these entries, we add each successive prime, which is stored in a pair
-- along with the number of them added together for that entry.  After each addition, each sum is
-- checked to see if it's a prime and if the count is larger than the largest seen, then store it.
-- After processing all of the primes, we should have the largest number of sequential primes when
-- added together that are a prime.

prob050 :: Int
prob050 = maxPrime
  where
    limit = 1000000
    -- Process each prime up to the limit.
    ((maxCount,maxPrime),_) = foldl' processAnotherPrime ((0,0),[]) primesToLimit
    primesToLimit = takeWhile (< limit) myPrimes
    processAnotherPrime :: ((Int,Int),[(Int,Int)]) -> Int -> ((Int,Int),[(Int,Int)])
    processAnotherPrime ((mxCount, mxPrime), workingList) newPrime
      = ((newMaxCount, newMaxPrime), (1, newPrime) : newWorkingList)
      where
        ((newMaxCount,newMaxPrime),newWorkingList)
          = foldl' addPrimeToList ((mxCount,mxPrime),[]) workingList
        addPrimeToList :: ((Int,Int),[(Int,Int)]) -> (Int,Int) -> ((Int,Int),[(Int,Int)])
        addPrimeToList ((currMaxCount,currMaxPrime),partialWorkingList)
                       (currCount,currPrimeSum) = newAccumulator
          where
            !newAccumulator = if newCurrPrimeSum <= limit
                              then (newMaxPair,(newCurrCount,newCurrPrimeSum):partialWorkingList)
                              else ((currMaxCount,currMaxPrime),partialWorkingList)
            !newCurrCount = currCount + 1
            !newCurrPrimeSum = currPrimeSum + newPrime
            !newMaxPair = if newCurrCount > currMaxCount && isPrime newCurrPrimeSum
                          then (newCurrCount, newCurrPrimeSum)
                          else (currMaxCount, currMaxPrime)

type P51MapElem = (PrimeT, Int)
type P51Map = HMS.HashMap String P51MapElem

prob051 :: PrimeT
prob051 = lookForSolution HMS.empty listOfPrimesWithCommonDigitStrings
  where
    numberToLookFor = 8
    listOfPrimesWithCommonDigitStrings = map intToStringsWithCommonDigitsMarked myPrimes

    -- This function takes a list of pairs of a number and then all strings related to it where one
    -- or more identical digits are replaced with a '-'.  It will insert each int a map with the key
    -- being the string and the value a pair consisting of the associated number when the key was
    -- first added and a count of the number of times encountered.  It will return the number of the
    -- element when a count reaches numberToLookFor.

    lookForSolution :: P51Map -> [(PrimeT, [String])] -> PrimeT
    lookForSolution _ [] = error "Null list in lookForSolution."
    lookForSolution mp ((prime, commonStrings) : restOfList)
      | leastPrimeCommon /= 0 = leastPrimeCommon
      | otherwise = lookForSolution newMap restOfList
      where
        (leastPrimeCommon, newMap) = addStrings mp commonStrings
        addStrings :: P51Map -> [String] -> (PrimeT, P51Map)
        addStrings currMap [] = (0, currMap)
        addStrings currMap (currString : otherStrings)
          | isNothing foundInMap = addStrings (HMS.insert currString (prime, 1) currMap) otherStrings
          | mapCount == numberToLookFor - 1 = (minPrimeForRelated, currMap)
          | otherwise = addStrings (HMS.insert currString newInsertValue currMap) otherStrings
          where
            foundInMap = HMS.lookup currString currMap
            (minPrimeForRelated, mapCount) = fromJust foundInMap
            newInsertValue = (minPrimeForRelated, mapCount + 1)

    -- This function will return a list of strings where one or more identical digits are
    -- replaced with a '-'.  For example:
    -- intToStringsWithCommonDigitsMarked 224323 = (224323, ["22432-","2243-3","224-23","224-2-",
    --     "22-323","2-4323","2-43-3","-24323","-243-3","--4323","--43-3"])

    intToStringsWithCommonDigitsMarked :: PrimeT -> (PrimeT, [String])
    intToStringsWithCommonDigitsMarked value = (value, iTSWCDM (reverse (show value)) '-' [])
      where
        iTSWCDM :: String -> Char -> String -> [String]

        -- If we have processed all of the digits, return the string if at least one of the digits
        -- was replaced by '-'.

        iTSWCDM [] ch soFar
          | ch == '-' = []
          | otherwise = [soFar]

        -- Depending on whether we have already chosen the current digit as the one to replace
        -- in this traversal, either substitute '-' for it or not, but either way, continue to
        -- the next digit.

        iTSWCDM (x : xs) ch soFar
          | ch == '-' || x == ch = nextNoSub ++ nextNewSub
          | otherwise = nextNoSub
          where
            nextNoSub  = iTSWCDM xs ch (x : soFar)
            nextNewSub = iTSWCDM xs x ('-' : soFar)

-- Only look at numbers staring with a 1 because larger ones will use one more digit when multiplied
-- by 6.

prob052 :: Int
prob052 = head $ filter sixMultiplesSameDigits [10^(x :: Int)+y | x <- [1..], y <- [1..(10^x-1)]]
  where
    sixMultiplesSameDigits value
      = null (dropWhile (\x -> sortedDigits == showAndSort (value * x)) [2..6])
      where
        showAndSort x = sort $ show x
        !sortedDigits  = showAndSort value

-- Calculate the Pascal's Triangle numbers in the right range and count the ones greater than
-- 1,000,000.  Since (comb n m) == (comb n (n-m)), only compute half of the numbers and count 1 or 2
-- depending on whether it there would be one or two when counting them all or not.  In other words,
-- only count one for the values where m == n-m.

prob053 :: Int
prob053 = sum [oneOrTwo x y | x <- [23..100], y <- [2..(x `quot` 2)], comb x y > 1000000]
  where
    oneOrTwo :: Int -> Int -> Int
    oneOrTwo x y = if even x && shiftL y 1 == x then 1 else 2

-- Used to hold a poker hand.  It turns out that all that's needed for this problem is the hand
-- value at the end.

data P54PokerHand = P54PokerHand {
    d_indexPairs   :: [(Int, Int)]
  , d_valCountArr  :: UV.Vector Int
  , d_suitCountArr :: UV.Vector Int
  , d_handValue    :: Int64
} deriving Show

prob054 :: IO Int
prob054 = do
  fileContents <- BC.readFile "prob054_in.txt"
  let linedFileContents = BC.lines fileContents :: [BC.ByteString]
      wordFileContents  = map BC.words linedFileContents :: [[BC.ByteString]]
      handListPairs     = map (splitAt 5) wordFileContents :: [([BC.ByteString], [BC.ByteString])]
      pokerHandPairs    = map (BF.bimap convListToHand convListToHand) handListPairs
  return (foldl' countFirstWinners 0 pokerHandPairs)
    where

      -- This is an accumulator function to be used in a fold.  It will count the number of cases
      -- where the first hand wins over the second hand.

      countFirstWinners :: Int -> (P54PokerHand, P54PokerHand) -> Int
      countFirstWinners acc (hand1, hand2)
        | d_handValue hand1 >= d_handValue hand2 = acc + 1
        | otherwise = acc

      -- Convert a list of cards represented as ByteStrings to a P54PokerHand, which contains a list
      -- of pairs representing the cards in the hand, a vector representing how many of each card
      -- rank there are, a vector representing how many of each suit there are, and an Int64
      -- representing the value of the hand, which can be compared with others to discover the
      -- better hand.

      convListToHand :: [BC.ByteString] -> P54PokerHand
      convListToHand list = P54PokerHand {d_indexPairs = indPairs, d_valCountArr = valCountArr,
                                          d_suitCountArr = suitCountArr, d_handValue = handValue}
        where
          handValue = highCardVal + shiftL firstPairVal 39 + shiftL secondPairVal 43
                                  + shiftL threeKindVal 47 + shiftL topStraightVal 51
                                  + shiftL flushVal 55     + shiftL fullHouseVal 56
                                  + shiftL fourKindVal 57  + shiftL straightFlushVal 61
                                  + shiftL royalFlushVal 62
          flushVal = UV.foldl' (\acc x -> if x == 5 then 1 else acc) 0 suitCountArr
          fullHouseVal = if threeKindVal == 1 && firstPairVal == 1 then 1 else 0
          straightFlushVal = if topStraightVal /= 0 && flushVal == 1 then 1 else 0
          royalFlushVal = if straightFlushVal == 1 && topStraightVal == 13 then 1 else 0
          (highCardVal, firstPairVal, secondPairVal, threeKindVal, fourKindVal)
            = UV.ifoldl' findMultiples (0, 0, 0, 0, 0) valCountArr
          (topStraightVal, _, _) = UV.ifoldl' findStraight (0, False, 0) valCountArr
          valCountArr  = UV.accum (+) (UV.replicate 14 0) (zip (map fst indPairs) (repeat 1))
          suitCountArr = UV.accum (+) (UV.replicate 5 0) (zip (map snd indPairs) (repeat 1))
          indPairs = map convToIndexes list

      -- This is an accumulator function to be used by a vector fold.  It will search for a straight
      -- in the hand and if found, will return the highest index of the straight.  If not found,
      -- this index will be zero.

      findStraight :: (Int64, Bool, Int) -> Int -> Int -> (Int64, Bool, Int)
      findStraight (lastOne, invalid, numberSeen) index count
        | invalid = (0, True, 0)
        | count == 0 && numberSeen > 0 && numberSeen < 5 = (0, True, 0)
        | count == 0 = (lastOne, invalid, numberSeen)
        | count == 1 = (fromIntegral index, invalid, numberSeen + 1)
        | otherwise = (0, True, 0)

      -- This is an accumulator function to be used by a fold.  The first argument is the
      -- accumulator, the second is the index of the Vector we are folding, and the third is the
      -- number of cards of that index in the hand.  Find the rank index of the first pair, second
      -- pair, three of a kind, and four of a kind.  These are only non-zero when they exist.  If
      -- there are two pairs, then the first one will be the lowest numbers and the second the
      -- highest.  Also, this function creates a highCard bit vector.  Essentially, this contains
      -- three bits for each card rank, and the number of cards of that rank in the hand are encoded
      -- in those three bits.  These bits are encoded from least to most significant bits in an
      -- Int64.  This is later used to compare the highest cards between two hands and will compare
      -- correctly for tied high cards.  This value will also be used later to set higher bits for
      -- the various ranked hands.

      findMultiples :: (Int64, Int64, Int64, Int64, Int64) -> Int -> Int
                       -> (Int64, Int64, Int64, Int64, Int64)
      findMultiples acc@(highCard, firstPair, secondPair, threeKind, fourKind) index count
        | count == 0 = acc
        | count == 1 = (newHighCard, firstPair, secondPair, threeKind, fourKind)
        | count == 2 = if firstPair == 0
                       then (newHighCard, index64, secondPair, threeKind, fourKind)
                       else (newHighCard, firstPair, index64, threeKind, fourKind)
        | count == 3 = (newHighCard, firstPair, secondPair, index64, fourKind)
        | count == 4 = (newHighCard, firstPair, secondPair, threeKind, index64)
        | otherwise = (0, 0, 0, 0, 0)
        where
          newHighCard = highCard + shiftL (fromIntegral count) ((index - 1) * 3)
          index64 = fromIntegral index

      -- Convert a ByteString representing a card to a pair with the first element the value index
      -- and the second the suit index, both one-based.

      convToIndexes :: BC.ByteString -> (Int, Int)
      convToIndexes str
        | BC.length str == 2  = (valInd, suitInd)
        | otherwise = (0, 0)
        where
          suitInd = case BC.head $ BC.tail str of 'C' -> 1; 'D' -> 2; 'H' -> 3; 'S' -> 4; _ -> 0
          valInd  = case BC.head str of '2'->1; '3'->2; '4'->3; '5'->4;  '6'->5;  '7'->6; '8'->7;
                                          '9'->8; 'T'->9; 'J'->10; 'Q'->11; 'K'->12; 'A'->13; _->0

-- Create a boxed array up to a limit higher than the number of Lychrel numbers we need to test,
-- and initialize it with calls to the isLychrel function for each.  As we walk through this array
-- to query whether each is a Lychrel number, the function will be evaluated.  This function will
-- Iterate the Lychrel test up to 50 times, but if one of the numbers other than the first is
-- within the array limit, then get the answer from the array.  This will set off a recursive
-- evaluation of the array, but whether a number withing the range of the problem is Lychrel or not
-- will only be evaluated once, not each time it is run across.

prob055 :: Int
prob055 = (length . filter id . map isLychrel) [1..9999]
  where
    arrayLimit = 20000
    searchLimit = 50
    arrayLimitInteger = fromIntegral arrayLimit :: Integer
    lychrelNumbers :: BA.Array Int Bool
    lychrelNumbers = BA.array (1, arrayLimit)
                     [(index, isLychrel (fromIntegral index)) | index <- [1..arrayLimit]]
    isLychrel :: Integer -> Bool
    isLychrel value = isLychrel' value 1
      where
        isLychrel' :: Integer -> Int -> Bool
        isLychrel' val count
          | count == searchLimit = True
          | count /= 1 && val <= arrayLimitInteger = lychrelNumbers BA.! fromIntegral val
          | palindromic reversedAndAdded = False
          | otherwise = isLychrel' reversedAndAdded (count + 1)
          where reversedAndAdded = val + (read . reverse . show) val

prob056 :: Int
prob056 = result
  where
    (result, _, _) = foldl' findMaxSumOfDigits (0, 0, 0)
                            [(a, b) | b <- [99,98..1], a <- [99,98..1]]
    findMaxSumOfDigits :: (Int, Integer, Int) -> (Int, Int) -> (Int, Integer, Int)
    findMaxSumOfDigits acc@(accMax, ignoreLimit, aLimit) (a, b)
      | a < aLimit = acc
      | aToTheB < ignoreLimit = (accMax, ignoreLimit, a)
      | currVal > accMax = (currVal, 10^(currVal `div` 9), aLimit)
      | otherwise = acc
      where
        aToTheB = fromIntegral a ^ b :: Integer
        currVal = (sum . map digitToInt . show) aToTheB

prob057 :: Int
prob057 = count
  where
    initialIntermediate = 1 % 2 :: Rational
    (count, _) = foldl' countExpansions (0, initialIntermediate) [1..1000]
    countExpansions :: (Int, Rational) -> Int -> (Int, Rational)
    countExpansions (currCount, currValue) _
      | numerLength == denomLength = (currCount, nextValue)
      | otherwise = (currCount + 1, nextValue)
      where
        currCompletion = currValue + 1
        nextValue = 1 / (currValue + 2)
        numerLength = (length . show) (numerator currCompletion)
        denomLength = (length . show) (denominator currCompletion)

-- My first solution to this took about 20 minutes to run.  I generated the same list of diagonal
-- entries, but walked through it and the list of primes stepping one list and the other depending
-- on what was smaller and looking for prime diagonal entries.  It is vastly faster to just call
-- isPrime on each diagonal entry because often it returns almost immediately False, and when it's
-- true it's only necessary to move up to the square root of the number.  Also many fewer primes
-- have to be generated.
-- Note that we can skip testing the last diagonal entry of a ring for primality because we know
-- it will be a square.

prob058 :: Int
prob058 = watchForDropBelow10 (tail diagonalValues) 3 4 0 1
  where
    diagonalValues = scanl (+) 1 (concatMap (replicate 4) [2,4..])
    watchForDropBelow10 :: [Int] -> Int -> Int -> Int -> Int -> Int
    watchForDropBelow10 [] _ _ _ _ = error "watchForDropBelow10 case should never happen."
    watchForDropBelow10 (d : ds) ring ringCount primeCnt nonPrimeCount
      | ringCount == 0 = if 10 * primeCnt < (primeCnt + nonPrimeCount)
                         then ring
                         else watchForDropBelow10 (d:ds) (ring + 2) 4 primeCnt nonPrimeCount
      | ringCount == 1 || not (isPrime d)
        = watchForDropBelow10 ds ring (ringCount - 1) primeCnt (nonPrimeCount + 1)
      | otherwise = watchForDropBelow10 ds ring (ringCount - 1) (primeCnt + 1) nonPrimeCount

-- Rather than looking for common words, look for the decryption key that results in the most spaces
-- in the decrypted text, as the space is by far the most common character.  Note that when doing
-- this, we don't have to try all 26x26x26 permutations, but can try 'a'-'z' for each key character
-- individually and use it to XOR with every third character in the input.  Finding each of these
-- decryption characters individually and concatenating them together will find the same key but by
-- only trying 3x26.

prob059 :: IO Int
prob059 = do
  fileContents <- readFile "prob059_in.txt"
  let
    rawChars :: [Int]
    rawChars = parseIntsFromString fileContents
    (as, bs, cs) = separateListIntoThree rawChars
    lowerCase = [(ord 'a')..(ord 'z')]
    (a, _) = foldl' (tryOption as) (0, 0) lowerCase
    (b, _) = foldl' (tryOption bs) (0, 0) lowerCase
    (c, _) = foldl' (tryOption cs) (0, 0) lowerCase
    result = sum $ zipWith xor rawChars (cycle [a, b, c])
  return result
    where
      spaceInt = ord ' '
      separateListIntoThree :: [a] -> ([a], [a], [a])
      separateListIntoThree lis = sLIT lis 0 [] [] []
        where
          sLIT :: [a] -> Int -> [a] -> [a] -> [a] -> ([a], [a], [a])
          sLIT [] _ as bs cs = (reverse as, reverse bs, reverse cs)
          sLIT (x : xs) 0 as bs cs = sLIT xs 1 (x : as) bs cs
          sLIT (x : xs) 1 as bs cs = sLIT xs 2 as (x : bs) cs
          sLIT (x : xs) 2 as bs cs = sLIT xs 0 as bs (x : cs)
          sLIT _ _ _ _ _ = error "sLIT case should not happen."
      tryOption :: [Int] -> (Int, Int) -> Int -> (Int, Int)
      tryOption rawChars acc@(_, maxSpaces) encVal
        | newMaxSpaces <= maxSpaces = acc
        | otherwise = (encVal, newMaxSpaces)
        where
          newMaxSpaces = foldl' (\ac x -> if x == spaceInt then ac + 1 else ac) 0 decryptedInts
          decryptedInts = map (`xor` encVal) rawChars

-- Problem 60 was interesting, and while not so difficult to solve, hard to make the solution fast.
-- The function prob060a was my first solution, and while clever, is complicated.  After solving it
-- that way, I looked at the discussion thread and saw a solution using list comprehensions.  It
-- used a hard limit as to how high it would search, and didn't incorporate some optimizations, so I
-- used that idea to build a function that would not use a hard limit.  It turned out, that while
-- that worked fine, it was much much slower because the strategy of starting with choosing a
-- maximum prime and then the minimim, second to minimum, etc., does a lot of repeated searching.
-- This is prob060b.  The fastest solution is prob060, and it has a hard limit, but makes it high
-- enough to insure that we have the smallest solution.  It also runs very fast.

-- The idea here is to use a pre-set maximum value, and work up from smallest to largest prime.

prob060 :: PrimeT
prob060 = result
  where
    result = head validFives  -- For some reason 'minimum validFives' takes much longer,
                              -- but just printing validFives doesn't.
    --    maxPrime = 26033  -- Use for insured smallest, but 3x slower.
    maxPrime = 8390
    primesWithout2And5 = 3 : drop 3 myPrimes
    validFives
      = [p5 + p4 + p3 + p2 + p1 |
         (p1, p1Rest) <- primesAndRest (takeWhile (< maxPrime) primesWithout2And5),
         let p1String = show p1; p1DigitSum = sumOfDigits p1String,
         (p2, p2Rest) <- primesAndRest (filterPrimesToLimit p1Rest p1String p1DigitSum maxPrime),
         let p2String = show p2; p2DigitSum = sumOfDigits p2String,
         (p3, p3Rest) <- primesAndRest (filterPrimesToLimit p2Rest p2String p2DigitSum maxPrime),
         let p3String = show p3; p3DigitSum = sumOfDigits p3String,
         (p4, p4Rest) <- primesAndRest (filterPrimesToLimit p3Rest p3String p3DigitSum maxPrime),
         let p4String = show p4; p4DigitSum = sumOfDigits p4String,
         (p5, _) <- primesAndRest (filterPrimesToLimit p4Rest p4String p4DigitSum maxPrime)
        ]
    primesAndRest :: [PrimeT] -> [(PrimeT, [PrimeT])]
    primesAndRest [] = []
    primesAndRest (p : ps) = (p, ps) : primesAndRest ps
    sumOfDigits :: String -> Int
    sumOfDigits str = let !digStr = map digitToInt str in sum digStr
    filterPrimesToLimit :: [PrimeT] -> String -> Int -> PrimeT -> [PrimeT]
    filterPrimesToLimit primeList verifyStr verifyDigitSum limit
      = filter compatiblePair (takeWhile (<= limit) primeList)
      where
        compatiblePair :: PrimeT -> Bool
        compatiblePair b
          = let !bStr = show b; !bDigSum = sumOfDigits bStr
            in ((verifyDigitSum + bDigSum `rem` 3) /= 0) && isPrime (read (verifyStr ++ bStr))
               && isPrime (read (bStr ++ verifyStr))

type P61SolutionSet = [Int]
type P61SolutionSetList = [P61SolutionSet]
type P61FullAndLastTwoPair = (Int, Int)
type P61ArrayIndexedByFirstTwoDigits = UA.Array Int [(Int, Int)]
type P61RemainingArrays = [P61ArrayIndexedByFirstTwoDigits]
type P61SearchState = ([P61FullAndLastTwoPair], P61SolutionSet, P61RemainingArrays)

prob061 :: Int
prob061 = sum $ head $ foldl' searchForAnswerGivenFirstIndex [] [10..99]
  where

    -- Take as input the appropriate figurate numbers and convert them to arrays indexed by the
    -- first two digits of each number that have as values lists of all numbers with those two
    -- digits first, containing a pair with the whole number and the last two digits.  For example
    -- the array for triangle numbers, where both 1035 and 1081 are elements, would have an entry in
    -- the array indexed by 10 of [(1035, 35), (1081, 81)].  Order the arrays sparsest to least
    -- sparse for search efficiency.  Separate out the first array and the rest, as the first will
    -- be used to start the search.

    (startArray : otherArrays)
        = map (createArray . numberSequenceToTuples)
              [octagonalNumbers, heptagonalNumbers, hexagonalNumbers, pentagonalNumbers,
               squareNumbers, triangleNumbers]

    -- Used in a fold to do a depth first search from the given index of the start array of values.

    searchForAnswerGivenFirstIndex :: [P61SolutionSet] -> Int -> [P61SolutionSet]
    searchForAnswerGivenFirstIndex accum startIndex = newAccum
      where
        beginSearchList = startArray UA.! startIndex

        -- Do a depth-first search from this point, which will return a list of all states reached
        -- during the search.  I wanted to use the dfs function to do this because it's such a
        -- simple function and concept, although I think the search could be done faster using
        -- methods I used in other Project Euler problems.

        searchList = dfsGeneric successors (beginSearchList, [], otherArrays)
        solutions = foldl' lookForSolutions [] searchList
        newAccum = accum ++ solutions

        -- Search the list of dfs states for solutions.  These will be cases where there are no
        -- remaining arrays to search, and where the next last two digits of the current number is
        -- the same as the start index, indicating a cycle found.  This is complicated a bit because
        -- from where we currently are in the search there may be multiple possible numbers, and we
        -- need to only return ones where the last two digits match the starting index.  If we do
        -- find a solution, add the associated full number to the list of solution numbers.

        lookForSolutions :: P61SolutionSetList -> P61SearchState -> P61SolutionSetList
        lookForSolutions acc (nextPoss, numbersSoFar, otherArrays')
          | null otherArrays' && fullNumberMatchingFirst /= 0
            = (fullNumberMatchingFirst : numbersSoFar) : acc
          | otherwise = acc
          where
            fullNumberMatchingFirst = foldl' findLastTwoMatchingStartIndex 0 nextPoss

            -- If the last two digits of this possibility are the same as the starting index, then
            -- return the full number.  This is used in a fold to find a match at the last step.
            -- Note that we know there is only one solution and the list we are searching is very
            -- short.  A more general solution would return a list of results.

            findLastTwoMatchingStartIndex :: Int -> P61FullAndLastTwoPair -> Int
            findLastTwoMatchingStartIndex acc' (fullNum, lastTwo)
              | lastTwo == startIndex = fullNum
              | otherwise = acc'

        -- Given a search state, generate the list of immediate successor states.  For each pair in
        -- the current list of options, generate a new state for each match with a remaining array
        -- of value, with the new state having the new set of options and having removed the array
        -- it came from.  Also, we add the current full number to the partial solution list.

        successors :: P61SearchState -> [P61SearchState]
        successors ([], _, _) = []
        successors ((fullNum, lastTwo) : xs, numbersSoFar, otherArrays')
          = successorsFromFirstOption ++ successors (xs, numbersSoFar, otherArrays')
          where
            successorsFromFirstOption = lookForMatchesInArrays otherArrays' []
            lookForMatchesInArrays :: P61RemainingArrays -> P61RemainingArrays -> [P61SearchState]
            lookForMatchesInArrays [] _ = []
            lookForMatchesInArrays (arr : arrs) searchedArrays
              | null currEl = lookForMatchesInArrays arrs (arr : searchedArrays)
              | otherwise = (currEl, fullNum : numbersSoFar, searchedArrays ++ arrs)
                            : lookForMatchesInArrays arrs (arr : searchedArrays)
              where currEl = arr UA.! lastTwo

    -- Used to initialize an array with the list of tuples.

    createArray :: [(Int, (Int, Int))] -> P61ArrayIndexedByFirstTwoDigits
    createArray = UA.accumArray (flip (:)) [] (10, 99)

    -- Takes in a sorted list of numbers, selects all of the four-digit numbers, and returns a tuple
    -- for each having a the number represented by the first two digits of the number, and second, a
    -- tuple with the original number and the two digit number that is the last two digits of the
    -- original number.  We also filter out any entries where the last two digits is less than 10.
    -- For example: [2345, 7203, 9442] -> [(23, (2345, 45)), (94, (9442, 42))]

    numberSequenceToTuples :: [Int] -> [(Int, (Int, Int))]
    numberSequenceToTuples = filter (\(_, (_, lastTwoDigitValue)) -> lastTwoDigitValue > 9)
                             . map convert . takeWhile (< 10000) . dropWhile (< 1000)
      where
        convert :: Int -> (Int, (Int, Int))
        convert value = (read firstTwoStr, (value, read lastTwoStr))
          where (firstTwoStr, lastTwoStr) = splitAt 2 (show value)

prob062 :: Int64
prob062 = smallestBase ^ (3 :: Int64)
  where
    smallestBase = lookForMatch 10 [] M.empty [(convertToCommonPerm (x*x*x), x) | x <- [1..]]
    numberOfPerms = 5
    goalMinusOne = numberOfPerms - 1
    convertToCommonPerm = sort . show

    -- Use a map to store a pair containing a count and the least number whose cube is represented
    -- by the key, which is the cube with the digits sorted.  Since entries are added with
    -- increasing cubes, we only need to store the first one and a count, which represents the
    -- number of base numbers that when cubed result in the same sorted digit number.  When we run
    -- across a number whose cube already is in the same group as enough other numbers, then store
    -- this as a potential answer.

    lookForMatch :: Int64 -> [String] -> M.Map String (Int64, Int64) -> [(String, Int64)] -> Int64
    lookForMatch _ _ _ [] = 0
    lookForMatch limit potential saved ((cubeSorted, baseVal) : xs)
      | count == goalMinusOne = lookForMatch limit (cubeSorted : potential) newMap xs
      | baseVal < limit = lookForMatch limit potential newMap xs
      | minAnswer > 0 = minAnswer
      | otherwise = let !newLimit = limit * 10 in lookForMatch newLimit [] M.empty xs
      where

        -- This is the current count and base associated with the new key.

        (count, _) = fromMaybe (0, 0) maybeValue

        -- Insert the pair of a base value and the sorted digits of its cube in the map, generating
        -- the value looked up, if there was one, and the new map.

        (maybeValue, newMap) = M.insertLookupWithKey combineFn cubeSorted (1, baseVal) saved
                               
        minAnswer = if null validAnswers then 0 else minimum validAnswers
        validAnswers = foldl' basesMatchingCount [] potential

        -- Look for potential answers that have exactly the wanted count.

        basesMatchingCount :: [Int64] -> String -> [Int64]
        basesMatchingCount acc x = let (cnt, val) = fromJust (M.lookup x saved)
                                   in if cnt == numberOfPerms then val : acc else acc

        -- This function is used to combine a pair being inserted to the map with a pair already
        -- associated in the map with the same key.  All it does is add the counts.

        combineFn :: String -> (Int64, Int64) -> (Int64, Int64) -> (Int64, Int64)
        combineFn _ (newCnt, _) (oldCnt, oldBase) = let !sm = newCnt + oldCnt in (sm, oldBase)
                 
-- This one was easy.  First, we only need to look at powers of 1 to 9, because 0 is not a positive
-- number and 10 raised to a power will always be of length longer than the power.  Moreso for
-- numbers larger than 10.  For each of the numbers from 1 to 9, there is some number of them in a
-- row (for increasing exponents) that are valid.  For 1, 2, and 3, there is only 1^1, 2^1, and 3^1,
-- but there are more for 4-8, and 9 has exponents 1-21.  Note that the exponentiation needs to be
-- done using Integer because the numbers get so big.  I used two different approaches, prob063a
-- which uses a list comprehension and some code to weed out invalid ones, and prob063, which scans
-- values iteratively for each number until the property is false.  In both cases I included code to
-- make sure all of the values are unique, although I don't think this is necessary.  Although
-- prob063 is longer than prob063a, it is about two times faster, although both are very fast.

prob063 :: Int
prob063 = (length . map head . group . sort) (concatMap lengthEqualsExponent [1..9])
  where
    lengthEqualsExponent :: Integer -> [Integer]
    lengthEqualsExponent n = accum n 1
      where
        accum currVal exponent'
          | currValIsValid = currVal : accum (currVal * n) (exponent' + 1)
          | otherwise = []
          where !currValIsValid = exponent' == length (show currVal)

-- I worked out the math for the continued fraction for a step, and then figured out how to
-- parameterize it so each loop would generate one number.  To determine when it has repeated, we
-- need to keep three values.  This runs very quickly, and more quickly by far than most posted
-- solutions.  There is a small optimization for the calculation of base, but more could be done.

prob064 :: Int
prob064 = countOdds 10000
  where
    countOdds :: Int -> Int
    countOdds value
      = length $ filter odd (map (length . snd . continuedSqrtFrac) [2..value])

prob065 :: Int
prob065 = result
  where
    termNumeratorToReport = 100
    result = (sum . map digitToInt . show . numerator) resultRatio
    resultRatio = continuedFractionNSteps continuousFractionRepresentationOfE
                                          (termNumeratorToReport - 1)

-- This problem was very hard to solve.  I tried walking up values of x and y in as efficient
-- way as I could, and well over 100 values of D never finished running all night.  After some
-- research, I found that solutions to this equation for X and Y will always correspond to the
-- numerator for X and denominator for Y of successive continued fraction aproximations of
-- the square root of D.  This search completes very quickly, and I improved it further by
-- parallelizing the search for each D value.

prob066 :: Int
prob066 = dVal
  where
    dLimit = 1000
    (dVal, _) = foldl' (\(accD, accX) (d, x) -> if x > accX then (d, x) else (accD, accX))
                       (0, 0) dXPairs
    dXPairs = zip dValues minXValues
    minXValues = parMap rpar firstValidXForD dValues
    dValues = reverse $ integersWithoutSquares dLimit
    firstValidXForD :: Int -> Integer
    firstValidXForD d = minX
      where
        minX = findValidXY successiveFractions
        successiveFractions = successiveTermsOfContinuedFraction (base, cycle cfCoof)
        (base, cfCoof) = continuedSqrtFrac d
        findValidXY :: [Rational] -> Integer
        findValidXY [] = 0
        findValidXY (x : xs)
          | validEquation = numer
          | otherwise = findValidXY xs
          where
            validEquation = numer * numer - fromIntegral d * denom * denom == 1
            numer = numerator x
            denom = denominator x
    integersWithoutSquares :: Int -> [Int]
    integersWithoutSquares limit = iws [1..limit] squareNumbers
      where
        iws :: [Int] -> [Int] -> [Int]
        iws _ [] = []
        iws [] _ = []
        iws allN@(n : ns) allS@(s : ss)
          | n < s = n : iws ns allS
          | n > s = iws allN ss
          | otherwise = iws ns ss
    
prob067 :: IO Int
prob067 = maximumPathSum "prob067_in.txt"

prob068 :: Int64
prob068 = maximum validOptions
  where
    validOptions = genValidOptions
    genValidOptions :: [Int64]
    genValidOptions = do

      -- For the first outer node, we can only look at the numbers up to 6, as we will still see all
      -- permutations, just not as many duplicates.  We have to add the numbers 7..10 back for the
      -- next option.

      let n1Range = [1..6] :: [Int64]
      n1 <- n1Range
      let n6Range = rangeMinusValue (7 : 8 : 9 : 10 : n1Range) n1
      n6 <- n6Range
      let n7Range = rangeMinusValue n6Range n6
      n7 <- n7Range
      let tripletSum = n1 + n6 + n7

      -- The sum of any line of three can't be less than 13 or more than 20.  We can probably use 14
      -- and 19, but I can't prove it.

      guard $ tripletSum >= 13 && tripletSum <= 20

      -- Choose the rest in the order that we can most quickly rule out possibilities.

      let n1String = concatNumbersIntoString n1 n6 n7
          n2Range = rangeMinusValue n7Range n7
      n2 <- n2Range
      let n8Range = rangeMinusValue n2Range n2
          n8 = tripletSum - n2 - n7
      guard $ elem n8 n8Range
      let n2String = concatNumbersIntoString n2 n7 n8
          n3Range = rangeMinusValue n8Range n8
      n3 <- n3Range
      let n9Range = rangeMinusValue n3Range n3
          n9 = tripletSum - n3 - n8
      guard $ elem n9 n9Range
      let n4Range = rangeMinusValue n9Range n9
      n4 <- n4Range
      let n10Range = rangeMinusValue n4Range n4
          n10 = tripletSum - n4 - n9
      guard $ elem n10 n10Range
      let n5Range = rangeMinusValue n10Range n10
          n5 = head n5Range
      guard $ n5 + n10 + n6 == tripletSum

      -- This guard limits the solutions to where the 10 is on one of the outer nodes, which it must
      -- be for the solution to have 16 digits.

      guard $ n5 == 10 || n4 == 10 || n3 == 10 || n2 == 10 || n1 == 10
      let n3String = concatNumbersIntoString n3 n8 n9
          n4String = concatNumbersIntoString n4 n9 n10
          n5String = concatNumbersIntoString n5 n10 n6
      return (minFirstForm [n1String, n2String, n3String, n4String, n5String])
    rangeMinusValue r v = [ x | x <- r, x /= v]
    concatNumbersIntoString a b c = show a ++ show b ++ show c

    -- Take in a list of the strings corresponding to the sets of three, find the one with the
    -- minimum first digit (not counting 10), and return an Int64 for them concatenated.

    minFirstForm :: [String] -> Int64
    minFirstForm listOfFiveStrings = read $ concat stringsInProperOrder
      where
        minFirstChar = (minimum . filter (/= '1') . map head) listOfFiveStrings
        stringsInProperOrder = take 5 $ dropWhile (\x -> head x /= minFirstChar)
                                                  (cycle listOfFiveStrings)

-- This was an interesting problem.  It seemed that the answer would be the product of the smallest
-- primes, which is 510510 = 2*3*5*7*11*13*17, and that turns out to be right.  I wanted to make
-- sure, and wrote a program that would calculate all of the phi values for the integers up to
-- 1,000,000 and comparing for the highest ratio.  I used my prime factors walk through function and
-- found that the version that runs in parallel is fastest.  This algorithm is very fast, especially
-- if the list of primes up to 1,000,000 have already been generated.

type P069Accum_t = (Int64, Double)

prob069 :: Int64
prob069 =  fst $ primeFactorWalkPar limit initAccum [] accBestRatio dfsPrimeToPFs id combineAccums
  where
    limit = 1000000
    initAccum = (0, 0.0)

    -- Given a list of accumulators, combine them into one with the highest ratio.

    combineAccums :: [P069Accum_t] -> P069Accum_t
    combineAccums = foldl' takeHighestRatio initAccum
      where
        takeHighestRatio acc@(_, accRatio) curr@(_, currRatio)
          | accRatio > currRatio = acc
          | otherwise = curr

    -- Check the ratio of the current value to the Phi of this value, and return the largest pair of
    -- the accumulated one so far or the current one.

    accBestRatio :: P069Accum_t -> Int64 -> [(Int, PrimeT)] -> P069Accum_t
    accBestRatio accum@(_, accRatio) currProd factors
      | currRatio > accRatio = (currProd, currRatio)
      | otherwise = accum
      where
        currPhi = computePhiFromListOfPrimeFactors factors
        currRatio = fromIntegral currProd / fromIntegral currPhi

-- The way this can be solved most simply.

_prob069a :: Int
_prob069a = 2 * 3 * 5 * 7 * 11 * 13 * 17

-- We are looking for the minimum ratio n/phi(n) for n <= 10^7, where n and phi(n) are permutations
-- of each other.  To maximize phi(n) and minimize the ratio, we will search for two primes near
-- sqrt(10^7) that multiplied together equal n.  If n = p1 * p2, and both p1 and p2 are prime, then
-- phi(n) = (p1-1)*(p2-1) Since we are looking for only results where n and phi(n) are permutations
-- of the same digits, we can check both to see if they are equal mod 9 before doing a more
-- expensive check.  Also, we know that n can't equal p^2 because then phi(n) would be p * (p-1) or
-- p^2 - p, so the difference between n and phi(n) would be p, but because p is prime, it couldn't
-- be divisible by 9, so n and phi(n) wouldn't be the same mod 9, so they couldn't be permutations
-- of the same digits.

-- The idea here is to take advantage of Haskell's lazy evaluation to conceptually search all
-- possible prime pairs, but to order the evaluation and prune when possible to minimize the actual
-- work done.  Conceptually, we will generate a list of all primes below sqrt(10^7), and order them
-- from largest to smallest.  Each of these primes p, will be paired with a list of primes from
-- (10^7 mod p) down to 2.  We then process the list keeping track of the lowest ratio found so far.
-- The list and sub-lists will be generated as needed.  For each prime p, search the list of
-- potential pairs until the ratio is bigger than the best we have already found, or we find a
-- better one.  If we find a better one, we are done with this prime and can go to the next since
-- any further found would have lower ratios.

prob070 :: PrimeT
prob070 = bestProduct
  where

    -- Start the search with a huge ratio as the best.

    (bestProduct, _) = processListForMinRatio (0, 100.0) primesAndLimitedRestPairs

    limit = 10000000
    sqrtLimit = (floor . sqrt) (fromIntegral limit :: Double)

    -- This is the list of pairs ready to process, and note that the primes in the secondary
    -- lists have been filtered by the mod 9 test.  The list looks like this:
    -- [(3137, [3119, 3083, 3011, ..., 5],
    --  (3121,[3]),
    --  (3119,[3191, 3137, 3083, ..., 17]),
    --  (3109, []),
    --  (3089, [3221, 3203, 3167, ..., 17]),
    --  ...,
    --  (2, [4999949, 4999913, 4999823, ..., 17])]
    -- Notice how primes only pair with other primes when the sum of both mod 9 is 10.  A
    -- further optimization is possible because of this so that each of these lists don't have
    -- to be filtered, but we generate lists of primes based on their value mod 9, and use them
    -- in conjunction with the mod value of the paired prime.

    primesAndLimitedRestPairs = map reverseAndLimitList primesAndRestPairs

    -- First generate a list of all primes under sqrt(10^7), pairing each with the list of all
    -- larger primes.  Reverse the list so we will search most efficiently later.  This list is
    -- fairly short, and will always be fully generated, although the lists of larger primes are
    -- unevaluated.
                                
    primesAndRestPairs = (reverse . genPrimesAndRestPairs) myPrimes

    -- Generate a list of all primes up to floor of sqrt(limit), each paired with continuing list on
    -- up from the prime.  Note that we don't include the initial prime in the lists because p^2
    -- won't be a permutation of it's phi value because in that case phi(p^2) = p(p-1), and the
    -- difference (p^2 - (p^2 - p) = p) isn't divisible by 9, since it is prime, and so they won't
    -- be permuations of the same digits.

    genPrimesAndRestPairs :: [PrimeT] -> [(PrimeT, [PrimeT])]
    genPrimesAndRestPairs [] = []
    genPrimesAndRestPairs (p : ps)
      | p > sqrtLimit = []
      | otherwise = (p, ps) : genPrimesAndRestPairs ps

    -- We have a pair containing a prime and a list of all primes larger than it.  Convert this to a
    -- pair with the prime and a list of all primes from the maximum one that when multiplied by the
    -- first prime is less than or equal to 10^7, down to 2, excluding the original prime, as we
    -- don't need to consider it (see above for the reasoning).  This also filters out any primes x
    -- where when multiplied by p won't share a common permutation of digits with phi(x*p).  We
    -- don't filter out all now because that would be expensive, but filter out the ones where the
    -- difference between x*p and phi(x*p) isn't 0 mod 9.  We know this by checking (p*x -
    -- (p-1)(x-1)) or (p + x - 1).

    reverseAndLimitList :: (PrimeT, [PrimeT]) -> (PrimeT, [PrimeT])
    reverseAndLimitList (p, ps)
      = let lim = limit `quot` p
            reversedPrimesFromPUpToLimitForThisP = (reverse . takeWhile (<= lim)) ps
            reversedPrimesUpToP = (reverse . takeWhile (< p)) myPrimes
            reversedPrimesUpToLimitForThisP
              = reversedPrimesFromPUpToLimitForThisP ++ reversedPrimesUpToP
            filteredForPossiblePermutationOfPhi
              = filter (\x -> (p + x - 1) `rem` 9 == 0) reversedPrimesUpToLimitForThisP
        in (p, filteredForPossiblePermutationOfPhi)

    -- Takes in a current value and associated ratio of the value and phi(value) as the best
    -- found so far.  Also takes the list of pairs containing a prime under sqrt(10^7) and an
    -- associated list of primes to pair it with to test.  The associated list is from the max
    -- possible that would work with the first prime down to 2.  First compute the maximum
    -- possible number paired with this prime, and if the ratio with them would not be better
    -- than the best found so far, then we are entirely done because every pair we would
    -- process from now on would be a worse ratio.  Otherwise, work our way through the list.

    processListForMinRatio :: (PrimeT, Double) -> [(PrimeT, [PrimeT])] -> (PrimeT, Double)
    processListForMinRatio bestSoFar [] = bestSoFar
    processListForMinRatio bestSoFar@(_, minRatio) ((currFirstPrime, prms) : rest)
      | minRatio < bestPossibleRatio = bestSoFar
      | otherwise = processListForMinRatio newBest rest
      where
        newBest = processListForMinRatioInner prms
        maxPossibleSecond = limit `quot` currFirstPrime
        bestPossibleRatio = fromIntegral (currFirstPrime * maxPossibleSecond)
                            / fromIntegral ((currFirstPrime - 1) * (maxPossibleSecond - 1))

        -- Given a prime currFirstPrime defined above, walk through the list of associated
        -- primes starting at the largest possible that when multiplied by currFirstPrime would
        -- be less than or equal to 10^7, and work down.  If we reach a point where the ratio
        -- is larger than the best we have found so far, then we can stop because all the rest
        -- in the list would be even larger.  If we find one where the ratio is better and phi
        -- and the product are permutations of the same digits, then return the better answer,
        -- as we don't need to go on with this list.

        processListForMinRatioInner :: [PrimeT] -> (PrimeT, Double)
        processListForMinRatioInner [] = bestSoFar
        processListForMinRatioInner (p : ps)
          | currRatio > minRatio = bestSoFar
          | sort (show currProduct) == sort (show currPhi) = (currProduct, currRatio)
          | otherwise = processListForMinRatioInner ps
          where
            currProduct = currFirstPrime * p
            currPhi = (currFirstPrime - 1) * (p - 1)
            currRatio = fromIntegral currProduct / fromIntegral currPhi

-- This is solvable fairly rapidly given the following observations:
-- 1) We can start with (1000000 * 3 `div` 7) / 1000000 as the closest fraction with 1000000 as the denominator.
-- 2) We can walk our way down to D==1 by decrementing the current D or N where we decrement N if
--    the current fraction is larger than 3/7, and decrement D if the current fraction is smaller than
--    the closest fraction found so far.  If we find one between the two, then that is the new closest
--    fraction.
-- 3) It may be possible to stop before we get to D==1, but I don't see exactly how to tell when.
--    It's not enough to say that the current gap between D/N and (D-1)/N is greater than the current
--    distance between the closest fraction found so far and 3/7, because one could still land in the
--    middle of the two.
-- 4) It is faster to keep the numerators and denominators separate rather than using rational numbers.
-- 5) When we have the best answer, it is not in reduced terms, but we can use Rational to do that.

prob071 :: Int64
prob071 = searchForClosest initialN initialD initialN initialD
  where
    upperN = 3
    upperD = 7
    initialN = initialD * upperN `div` upperD
    initialD = 1000000
    searchForClosest :: Int64 -> Int64 -> Int64 -> Int64 -> Int64
    searchForClosest currN currD lowerN lowerD
      | currD == 0 = numerator (lowerN % lowerD)
      | currN * upperD >= currD * upperN = newN `seq` searchForClosest newN currD lowerN lowerD
      | currN * lowerD <= currD * lowerN = newD `seq` searchForClosest currN newD lowerN lowerD
      | otherwise = newN `seq` (newD `seq` searchForClosest newN newD currN currD)
      where
        newN = currN - 1
        newD = currD - 1

prob072 :: Int64
prob072 = primeFactorWalkPar 1000000 0 (0, 1) accSumPhi dfsGenPhi id sum

prob073 :: Int
prob073 = sum reducedFractionCountByDenomBetweenThirdAndHalf
  where
    reducedFractionCountByDenomBetweenThirdAndHalf = map reducedFracCount [5..12000]
    reducedFracCount denom
      | isPrime denom = maxNumer - minNumerDraft + 1
      | otherwise = reducedFracCount' minNumer 0
      where
        minNumerDraft = (denom `quot` 3) + 1
        minNumer = if even denom && even minNumerDraft then minNumerDraft + 1 else minNumerDraft
        maxNumer = (denom `quot` 2) - (if odd denom then 0 else 1)
        inc = if even denom then 2 else 1
        reducedFracCount' currN acc
          | currN > maxNumer = acc
          | otherwise = let newN = currN + inc
                            newAcc = if isPrime currN || gcd currN denom == 1
                                     then acc + 1
                                     else acc
                        in newN `seq` (newAcc `seq` reducedFracCount' newN newAcc)

-- Using boxed vectors for the chain length works well and is fast and clear.  I implemented a
-- faster version of this in C++, but it's only 2x faster, and is much more complex.

prob074 :: Int
prob074 = V.foldl' (\acc x -> if x == 60 then acc + 1 else acc) 0 chainLengths
  where
    limit = 1000000
    digitFactVec = UV.fromList $ scanl1 (*) (1:[1..9])
    sumOfFactDigits = sum . map (\x -> digitFactVec UV.! (ord x - ord '0')) . show
    chainLengths :: V.Vector Int8
    chainLengths = V.generate limit chainLengthValue

    -- This function is used to fill in the array of chain lengths.  It has to check for the known
    -- values that loop (provided in the problem) or the initialization of the vector will loop.
    -- Note that will only work with boxed vectors not unboxed ones.

    chainLengthValue index
      | index == 871 || index == 872 || index == 45361 || index == 45362 = 2
      | index == 169 || index == 1454 || index == 363601 = 3
      | index == nextValue = 1
      | otherwise = findFirstUnderLimit nextValue 1
      where
        nextValue = sumOfFactDigits index
        findFirstUnderLimit :: Int -> Int8 -> Int8
        findFirstUnderLimit value count
          | value < limit = (chainLengths V.! value) + count
          | otherwise = findFirstUnderLimit (sumOfFactDigits value) (count + 1)
                   
-- Tried lots of ways of generating Pythagorean Triples for this one, and the tree of primitives
-- approach was by far the best.  Interestingly, it is faster to generate tripleSums and then
-- tripleSumsWithOne in two steps than just one.

prob075 :: Int
prob075 = sumSingles
  where
    maxSearchSum = 1500000 :: Int
    vectorMax = fromIntegral maxSearchSum + 1 :: Int
    sumSingles :: Int
    sumSingles = UV.foldl' (\acc x -> acc `seq` (if x == 1 then acc + 1 else acc)) 0 sumCount
    sumCount :: UV.Vector Int
    sumCount = UV.accum (+) (UV.replicate vectorMax 0) tripleSumsWithOne
    tripleSumsWithOne :: [(Int,Int)]
    tripleSumsWithOne = map (, 1) tripleSums
    tripleSums :: [Int]
    tripleSums = map (\(a,b,c) -> a+b+c) triplesInRange
    triplesInRange :: [(Int, Int, Int)]
    triplesInRange = pythagoreanTriplesPrimTree (ptptWithinLimitPerimeter maxSearchSum)

-- I figured out a recurrence for this based on keeping track of the number of partitions of a
-- certain number with a maximum limit for the size of one of the partition numbers.  Using this, we
-- can see that P(n, j) = 1 for j == 0,1 and P(n, j-1) + P(n-1,min(j,n-j)).
-- From zero to 5 these numbers are:
--
-- 0 : 1
-- 1 : 1 1
-- 2 : 1 1 2
-- 3 : 1 1 2 3
-- 4 : 1 1 3 4 5
-- 5 : 1 1 3 5 6 7
--
-- So, for the last row, there are 7 ways to add up one or more positive integers to get 5.
-- There are 6 ways to add up integers where the maximum number is 4.  There are 5 where the
-- maximum is 3, etc.

prob076 :: Word
prob076 = ((partitions V.! limit) V.! limit) - 1
  where
    limit = 100
    vec_size = limit + 1
    partitions :: V.Vector (V.Vector Word)
    partitions = V.generate vec_size (\ind -> V.generate (ind + 1) (partitionPart ind))
    partitionPart :: Int -> Int -> Word
    partitionPart partIndex innerIndex
      | innerIndex <= 1 = 1
      | otherwise = ((partitions V.! partIndexLook) V.! partInnerIndexLook)
                    + ((partitions V.! partIndex) V.! (innerIndex - 1))
      where
        partIndexLook = partIndex - innerIndex
        partInnerIndexLook = if innerIndex > partIndexLook then partIndexLook else innerIndex

-- This solution is similar to 76, but we only look at those answers for prior partitions for
-- cases where the difference between the current and the prior is a prime.

prob077 :: Int
prob077 = maybe 0 fst answerPair
  where
    limit = 75
    ansThreshold = 5000
    vec_size = limit + 1
    answerPair = find (\(_, px) -> px > ansThreshold) partitionsList
    partitionsList = [(x, (primePartitions V.! x) V.! x) | x <- [1..limit]]
    primePartitions :: V.Vector (V.Vector Int)
    primePartitions = V.generate vec_size (\ind -> V.generate (ind + 1) (partitionPart ind))
    partitionPart :: Int -> Int -> Int
    partitionPart partIndex innerIndex
      | innerIndex <= 1 = 0
      | partIndex == innerIndex && isPrime innerIndex = partitionsWithMaxOneLess + 1
      | isPrime innerIndex = partitionsWithMaxOneLess + newCombinations
      | otherwise = partitionsWithMaxOneLess
      where
        partitionsWithMaxOneLess = (primePartitions V.! partIndex) V.! (innerIndex - 1)
        newCombinations = (primePartitions V.! partIndexLook) V.! partInnerIndexLook
        partIndexLook = partIndex - innerIndex
        partInnerIndexLook = if innerIndex > partIndexLook then partIndexLook else innerIndex

-- Use the recurrence defined in Knuth for integer partitions.  Since we are only interested in
-- those answers evenly divisible by 1000000, mod the values as we go and then when doing the final
-- subtraction, add 1000000 to the first number so as not to go negative.

prob078 :: Int
prob078 = fromMaybe 0 foundAnswer
  where
    foundAnswer = V.findIndex (== 0) partitions
    limit = 60000
    vec_size = limit + 1
    partitions :: V.Vector Word
    partitions = V.generate vec_size partitionRecurrence
    partitionRecurrence :: Int -> Word
    partitionRecurrence 0 = 1
    partitionRecurrence index = partRecurr True 1 2 4 5 0
      where
        partRecurr addTo firstAdj secondAdj firstInc secondInc acc
          | secondAdj >= index = newAcc
          | otherwise
            = let newFirstAdj  = firstAdj + firstInc
                  newSecondAdj = secondAdj + secondInc
                  newFirstInc  = firstInc + 3
                  newSecondInc = secondInc + 3
              in partRecurr (not addTo) newFirstAdj newSecondAdj newFirstInc newSecondInc newAcc
          where
            newAcc = (if addTo then acc + firstAdd + secondAdd
                               else 2000000 + acc - firstAdd - secondAdd) `rem` 1000000
            firstAdd = zeroOrIndex (index - firstAdj)
            secondAdd = zeroOrIndex (index - secondAdj)
            zeroOrIndex ind = if ind < 0 then 0 else partitions V.! ind

-- This problem was easy to figure out on paper, but I wanted to write code to do it as well.  It
-- assumes that the passcode only has one of any digit, which wasn't clear from the problem, but is
-- true of the answer.  I didn't fully see how to solve this problem if there could be repeated
-- digits.

prob079 :: IO Int
prob079 = do
  listOfStrings <- fmap lines (readFile "prob079_in.txt")
  return ((read . deducePassCode []) listOfStrings)
  where
    deducePassCode :: String -> [String] -> String
    deducePassCode acc [] = reverse acc
    deducePassCode acc hints
      | length unique1stCharList == 1 = deducePassCode (unique1stChar : acc) newHints
      | otherwise = []
      where
        unique1stChars = (removeDups [] . sort . map head) hints
        allNon1stChars = concatMap tail hints
        unique1stCharList = filter (\ch -> isNothing $ find (== ch)  allNon1stChars)
                                   unique1stChars
        unique1stChar = head unique1stCharList
        newHints = (filter (not . null)
                    . map (\x -> if head x == unique1stChar then tail x else x)) hints

prob080 :: Int
prob080 = sum sumsOfFirst100Digits
  where
    limit = 100
    sumsOfFirst100Digits = map (sum . take 100 . map digitToInt . show) first100DigitsList
    first100DigitsList = map computeAccurateEnoughRationals nonSquareRootsCFRep
    nonSquareRootsCFRep = (filter (\(_, rep) -> not $ null rep)
                           . map continuedSqrtFrac) [1..limit]
    tenTo100 = 10^(100 :: Integer) :: Integer
    errorLimit = 1 % tenTo100
    computeAccurateEnoughRationals :: (Int, [Int]) -> Integer
    computeAccurateEnoughRationals (base, cfList)
      = caer (successiveTermsOfContinuedFraction (base, cycle cfList))
      where
        caer :: [Rational] -> Integer
        caer [] = 0
        caer [_] = 0
        caer (r1 : r2 : rs)
          | abs (r2 - r1) < errorLimit = let x = r2 * (tenTo100 % 1)
                                         in numerator x `quot` denominator x
          | otherwise = caer rs

-- This one is pretty straightforward.  Read in the file and from them, create a vector of vectors
-- containing the minimum cost of getting to each location by taking the minimum from above and from
-- the left and adding the current value of the square.  We then just check the lower right corner
-- and have the answer.  This could be done using a graph, but it's easy enough to do this way, and
-- it uses the ability of Haskell to initialize a vector that is recursive and because of lazy
-- evaluation, the values aren't computed until needed, when the entire vector is populated with
-- actual values.

prob081 :: IO Int
prob081 = do
  fileContents <- BC.readFile "prob081_in.txt"
  let linedFileContents = BC.lines fileContents
      wordFileContents = map (BC.split ',') linedFileContents
      intFileContents = map convertByteStringsToInts wordFileContents
      rowCount = length intFileContents
      colCount = length $ head intFileContents
      inputLists :: V.Vector [Int]
      inputLists = V.fromList intFileContents
      inputTable :: V.Vector (UV.Vector Int)
      inputTable = V.generate rowCount (\ind -> UV.fromList (inputLists V.! ind))
      minPathTable :: V.Vector (V.Vector Int)
      minPathTable = V.generate rowCount (V.generate colCount . minPathVal)
      minPathVal :: Int -> Int -> Int
      minPathVal rowInd colInd
        | rowInd == 0 && colInd == 0 = currSquareValue
        | rowInd == 0 = valueFromLeft
        | colInd == 0 = valueFromAbove
        | otherwise = min valueFromAbove valueFromLeft
        where
          currSquareValue = (inputTable V.! rowInd) UV.! colInd
          pathOneUp = (minPathTable V.! (rowInd - 1)) V.! colInd
          pathOneLeft = (minPathTable V.! rowInd) V.! (colInd - 1)
          valueFromAbove = pathOneUp + currSquareValue
          valueFromLeft  = pathOneLeft + currSquareValue
  return ((minPathTable V.! (rowCount - 1)) V.! (colCount - 1))

-- After solving this with Dijkstra's shortest path algorithm, I saw a comment in the thread by
-- brettPaufler that I wanted to implement.  This solutions uses dynamic programming and a trick to
-- insure that the best start/end solution is found with a single pass.  We want to find the
-- shortest path from a square in the first column to a square in the second column.  The trick is
-- to add a column on the left and one on the right with all zero weights, and then search for the
-- shortest path from corner to corner.  The implementation strategy is to store the weights in a
-- vector of columns (not rows as in 81).  The initialization of the solution vector then
-- initializes column by column (lazily) from left to right, and generates each column iteratively
-- until it no longer changes.  When done, the shortest distance will be in all of the end column
-- elements.

prob082 :: IO Int
prob082 = do
  fileContents <- BC.readFile "prob082_in.txt"
  let linedFileContents = BC.lines fileContents
      wordFileContents = map (BC.split ',') linedFileContents
      intFileContents = map convertByteStringsToInts wordFileContents :: [[Int]]
      intListsWithZeros = map (\lis -> (0 : lis) ++ [0]) intFileContents
      rowCount = length intListsWithZeros
      colCount = length $ head intListsWithZeros

      -- A vector of the input lists, each containing a full row of the input.  Used for
      -- initialization.

      inputLists :: V.Vector [Int]
      inputLists = V.fromList intListsWithZeros

      -- Create a table with rows being the first index and columns the second.  This is much easier
      -- to initialize from the lists we have than to have a table indexed the other way.  This can
      -- then be used to initialize a table indexed the other way whose initialization can be done
      -- iteratively by column.

      inputTableRowsOfColumns :: V.Vector (UV.Vector Int)
      inputTableRowsOfColumns = V.generate rowCount (\ind -> UV.fromList (inputLists V.! ind))

      -- Initialize this table with columns as the first index and rows as the second.

      inputTableColsOfRows :: V.Vector (UV.Vector Int)
      inputTableColsOfRows
        = V.generate colCount (\indC -> UV.generate rowCount
                                        (\indR -> (inputTableRowsOfColumns V.! indR) UV.! indC))

      -- This table will hold the shortest path to each point, and we can pluck the answer from any
      -- of the elements of the last column.

      shortestPathTable :: V.Vector (V.Vector Int)
      shortestPathTable = V.generate colCount (\col -> iterUntilSettles col (initialColumn col))

      -- Generate an initial estimated column for the initialization of shortestPathTable.  Just use
      -- the column to the left plus the weight for each element.

      initialColumn :: Int -> V.Vector Int
      initialColumn 0 = V.generate rowCount (\row -> (inputTableColsOfRows V.! 0) UV.! row)
      initialColumn col = V.generate rowCount (\row -> ((shortestPathTable V.! (col - 1)) V.! row)
                                                        + ((inputTableColsOfRows V.! col) UV.! row))

      -- This function is used to initialize a column in shortestPathTable, with the requirement
      -- that all columns to the left have been initialized.  The idea is to take in an initial
      -- vector and compute a new one based on it and the column to the left.  For each element, use
      -- the minimum of the square to the left plus the current weight, the square above plus the
      -- current weight, and the square below plus the current weight.  The values in this vector
      -- will settle down with just a few iterations, and when they have, return the vector.

      iterUntilSettles :: Int -> V.Vector Int -> V.Vector Int
      iterUntilSettles 0 initVec = initVec
      iterUntilSettles col currVec
        | currVec == newVec = currVec
        | otherwise = iterUntilSettles col newVec
        where
          newVec = V.generate rowCount minRowValFromThreeDirections
          minRowValFromThreeDirections row
            | row == 0 = minimum [weightFromLeft, weightFromBelow]
            | row == (rowCount - 1) = minimum [weightFromLeft, weightFromAbove]
            | otherwise = minimum [weightFromLeft, weightFromAbove, weightFromBelow]
            where
              !currWeight = (inputTableColsOfRows V.! col) UV.! row
              weightFromLeft = ((shortestPathTable V.! (col - 1)) V.! row) + currWeight
              weightFromAbove = (currVec V.! (row - 1)) + currWeight
              weightFromBelow = (currVec V.! (row + 1)) + currWeight

  return ((shortestPathTable V.! (colCount - 1)) V.! 0)

-- This one is very similar to 82.  Different start and end nodes, and more arcs, but the same graph
-- search.

prob083 :: IO Int
prob083 = do
  fileContents <- BC.readFile "prob083_in.txt"
  let linedFileContents = BC.lines fileContents
      wordFileContents = map (BC.split ',') linedFileContents
      intFileContents = map convertByteStringsToInts wordFileContents :: [[Int]]
      colCount = length $ head intFileContents

      -- With intFileContents, we have a list of lists of ints representing the rows of values in
      -- the problem.  We need to process these to get a list of nodes and a list of edges to make a
      -- graph out of and to feed to the fgl inductive graph package.

      gNodes :: [GR.LNode Int]
      gEdges :: [GR.LEdge Int]
      (gNodes, gEdges, _, nextInd) = foldl gatherNodesAndEdges ([], [], [], 0) intFileContents

      -- Create a graph using the one defined in PatriciaTree with an int associated with both the
      -- nodes and the edges, each representing the weight.  The weights for edges are the same as
      -- the weights in the problem for the destination node, and the weights for the nodes are the
      -- same as the ones in the problem.

      myGraph :: GRPT.Gr Int Int
      myGraph = GR.mkGraph gNodes gEdges
      path :: [GR.Node]
      path = fromJust (GRSP.sp 0 (nextInd - 1) myGraph)

      -- The 'sp' (shortest path) function returns the path based on nodes visited.  We convert
      -- these to the value associated with each node, then sum them.  Note that the path includes
      -- the start node and the end node, neither of which are in the problem, but they have zero
      -- weights.

      pathVals = map (fromJust . GR.lab myGraph) path
      pathSum = sum pathVals

      -- Used in a fold to walk through the list of rows.  Accumulate nodes and edges for graph
      -- creation.

      gatherNodesAndEdges :: ([GR.LNode Int], [GR.LEdge Int], [Int], Int) -> [Int]
                             -> ([GR.LNode Int], [GR.LEdge Int], [Int], Int)
      gatherNodesAndEdges (accNodes, accEdges, lastRow, nextI) rowOfWeights
        = (newNodes, newEdges, rowOfWeights, newNextInd)
        where
          (newNodes, newEdges, _, _, _, newNextInd)
            = foldl gatherNodesAndEdgesInner (accNodes, accEdges, lastRow, -1, -1, nextI)
                    rowOfWeights

          -- Used in a fold to gather nodes and edges.  For each node, create an edge back, one up,
          -- and one down where possible.

          gatherNodesAndEdgesInner :: ([GR.LNode Int], [GR.LEdge Int], [Int], Int, Int, Int)
                                      -> Int -> ([GR.LNode Int], [GR.LEdge Int], [Int], Int, Int, Int)
          gatherNodesAndEdgesInner (accNodes', accEdges', lastRow', lastInd, lastWeight, nextInd') weight
            = (newNodes', newEdges', newLastRow, nextInd', weight, nextInd' + 1)
            where
              newNodes' = (nextInd', weight) : accNodes'
              newEdges1 = if lastInd == -1
                          then accEdges'
                          else (lastInd, nextInd', weight) : (nextInd', lastInd, lastWeight) : accEdges'
              newEdges' = if null lastRow'
                          then newEdges1
                          else (nextInd', weightAboveInd, weightAbove)
                               : (weightAboveInd, nextInd', weight)
                               : newEdges1
              weightAbove = head lastRow'
              weightAboveInd = nextInd' - colCount
              newLastRow = if null lastRow' then lastRow' else tail lastRow'
  return pathSum

data MonopSquare = GO | A1   | CC1 | A2  | T1  | R1 | B1 | CH1 | B2  | B3
                      | Jail | C1  | U1  | C2  | C3 | R2 | D1  | CC2 | D2  | D3
                      | FP   | E1  | CH2 | E2  | E3 | R3 | F1  | F2  | U2  | F3
                      | G2J  | G1  | G2  | CC3 | G3 | R4 | CH3 | H1  | T2  | H2 deriving (Enum, Eq)
type P84BoardProbState = UV.Vector Double
type P84MarkovState = (P84BoardProbState, Word)
                                                                                  
prob084 :: Int
prob084 = read result
  where

    -- When the maximum change for the probability of being on any square between iterations is less
    -- than this amount, then consider that the distribution has settled enough to get the correct
    -- answer.

    maxChangeBetweenIterations = 0.000001 :: Double

    -- We represent the Markov state as a 120-element vector of doubles, where the first 40
    -- represent the probability of being on each square of the board having no double rolled the
    -- last time (or having been sent to jail, which resets the count). The second set of 40
    -- represent the probability of being on each square of the board having one double rolled to
    -- get you there.  The third set of 40 represents the prior two rolls having been doubles.  We
    -- start with a probability of 1/39 in all of the no-prior-double squares except Go To Jail,
    -- which seems to settle fairly quickly.

    initialState = (initialDistribution, 0) :: P84MarkovState
    initialDistribution = UV.accum (+) (UV.replicate 120 0.0) [(i, 1.0/39) | i <- [0..39], i /= 30]

    -- We iterate on the state until the probabilities settle down, and then collapse them into one
    -- vector of size 40 before finding the most probable three.

    result = concatMap (\(_, i) -> if i < 10 then '0' : show i else show i) topThreeSquares
    topThreeSquares = take 3 sortedSettledDistWithInd
    sortedSettledDistWithInd = sortBy (flip compare) settledDistWithIndexes
    settledDistWithIndexes = zip (UV.toList resultDistCollapsed) ([0..] :: [Int])
    resultDistCollapsed = UV.accum (+) (UV.replicate 40 0.0)
                                       (UV.ifoldl' collapseProbs [] settledDistribution)
    (settledDistribution, _) = findSettledDistribution iteratedDistributions
    iteratedDistributions = iterate distributeRollsAcrossFullBoard initialState

    collapseProbs :: [(Int, Double)] -> Int -> Double -> [(Int, Double)]
    collapseProbs acc ind prob = (collapsedIndex, prob) : acc
      where
        collapsedIndex
          | ind > 79  = ind - 80
          | ind > 39  = ind - 40
          | otherwise = ind

    -- Assume an infinite list of successive probability distributions for the Monopoly board.  Walk
    -- through the list comparing adjacent distributions until the maximum difference for a square
    -- between two successive distributions is less than the limit defined above.

    findSettledDistribution :: [P84MarkovState] -> P84MarkovState
    findSettledDistribution listOfInStates
      | maxChange < maxChangeBetweenIterations = state2
      | otherwise = findSettledDistribution (state2 : remaining)
      where
        ((vec1, _) : state2@(vec2, _) : remaining) = listOfInStates
        maxChange = UV.foldl' (\acc (v1, v2) -> let diff = abs (v1 - v2)
                                                in if acc > diff then acc else diff)
                              0.0 (UV.zip vec1 vec2)

    -- Take in a board state, process it for all squares and dice roll probabilities, and return the
    -- resulting board state, which is the next in the Markov analysis.

    distributeRollsAcrossFullBoard (inputVec, settleCount)
      = let !newSettleCount = settleCount + 1
        in (UV.accum (+) (UV.replicate 120 0.0) distributionAdditionsList, newSettleCount)
      where
        jailIndex = fromEnum Jail
        distributionAdditionsList = UV.ifoldl' distBoardSquare [] inputVec

        distBoardSquare :: [(Int, Double)] -> Int -> Double -> [(Int, Double)]
        distBoardSquare acc _ 0.0 = acc
        distBoardSquare acc ind currProb = newAcc
          where
            priorConsecutiveDoubles
              | ind > 79  = 2
              | ind > 39  = 1
              | otherwise = 0
            boardSquare = ind - 40 * priorConsecutiveDoubles
            newAcc = foldl' newProbabilities acc validRolls

            newProbabilities :: [(Int, Double)] -> Int -> [(Int, Double)]
            newProbabilities accNP roll

              -- If we are processing a board square and it is among the ones having had two prior
              -- double rolls, then only process the non doubles, then add being sent to Jail in the
              -- section indicating no doubles.

              | priorConsecutiveDoubles == 2
                = (jailIndex, probDoublesWithSquare) : newAccNPAddedNonDoubles
              | otherwise = newAccNPWithAll
              where
                newAccNPAddedNonDoubles = distForChanceCCAndDoubles False accNP bdSquareEnum
                                            probNoDoublesWithSquare 
                newAccNPWithAll = distForChanceCCAndDoubles True newAccNPAddedNonDoubles
                                         bdSquareEnum probDoublesWithSquare

                !probNoDoublesWithSquare = probOfThisRollNoDoubles * currProb
                !probDoublesWithSquare = probOfThisRollWithDoubles * currProb
                !initNextBoardSquare = (boardSquare + roll) `rem` 40
                !probOfThisRollNoDoubles = probOfThisRoll - probOfThisRollWithDoubles
                !probOfThisRollWithDoubles = probOfThisRoll * probOfDoubles
                !probOfThisRoll = diceDistribution UV.! roll
                !probOfDoubles = doublesProb UV.! roll
                !bdSquareEnum = toEnum initNextBoardSquare

                -- Being sent to jail because of triple doubles has been taken care of before this
                -- was called.

                distForChanceCCAndDoubles :: Bool -> [(Int, Double)] -> MonopSquare -> Double
                                             -> [(Int, Double)]
                distForChanceCCAndDoubles _ accDist _ 0.0 = accDist
                distForChanceCCAndDoubles doubleRolled accDist indexEnum prob

                  -- If we landed on Go To Jail, whether we have rolled doubles before or not, go to
                  -- Jail.  Judging from the posted answers for this problem, we must not reset the
                  -- consecutive doubles when being sent to jail for reasons other than triple
                  -- doubles.

                  | indexEnum == G2J = (jailIndex + (40 * newConsecutiveDoubles), prob) : accDist

                  -- For Community Chest and Chance, distribute the probability over the various
                  -- places you can end up.

                  | indexEnum == CC1 || indexEnum == CC2 || indexEnum == CC3
                    = (destIndex, prob * 14.0 / 16.0) : foldr consOneSixteenth accDist [GO, Jail]
                  | indexEnum == CH1 = foldr consOneSixteenth commonForAllChance [R2, R2, U1, T1]
                  | indexEnum == CH2 = foldr consOneSixteenth commonForAllChance [R3, R3, U2, D3]
                  | indexEnum == CH3 -- In this case, we have to recursively call for CC3.
                    = foldr consOneSixteenth commonAndHandleCommunityChest3 [R1, R1, U1]
                  | otherwise = (destIndex, prob) : accDist
                  where

                    !newConsecutiveDoubles = if doubleRolled then priorConsecutiveDoubles + 1 else 0
                    destIndex = fromEnum indexEnum + (40 * newConsecutiveDoubles)

                    -- When distributing from a Chance square, for most of the cards, it doesn't
                    -- matter which Chance square is landed on, so we handle those here.  For those
                    -- that are different depending on the specific square, they are handled
                    -- individually above.

                    commonForAllChance = (destIndex, prob * 6.0 / 16.0) :
                                         foldr consOneSixteenth accDist [GO, Jail, C1, E3, H2, R1]

                    commonAndHandleCommunityChest3 = distForChanceCCAndDoubles doubleRolled
                                                     commonForAllChance CC3 (prob * oneSixteenth)

                    -- Add the given square with one sixteenth the probability to the accumulator.
                    -- This is used to handle individual Chance and Community Chest cards.

                    consOneSixteenth square accIn = (squareIndex, newProb) : accIn
                      where
                        !squareIndex = fromEnum square + (40 * newConsecutiveDoubles)
                        !newProb = prob * oneSixteenth
                    !oneSixteenth = 1.0 / 16

    -- We create dice probability distribution (for both four-sided and six-sided dice) vectors and
    -- corresponding vectors indicating the portion of ways to achive the dice total with doubles.
    -- For example, with two six-sided dice, there are 3 * 1/36 ways to roll a 4, and 0.333 of these
    -- are doubles (2 and 2).
    -- Uncomment one or the other of the first two lines here to use either six- or four-sided dice.

    (validRolls, diceDistribution, doublesProb) = (validRolls44, diceDistribution44, doublesProb44)

    validRolls44 = [2..8]
    diceDistribution44 = UV.fromList (0.0 : 0.0 : probs44For2To8) :: UV.Vector Double
    doublesProb44 :: UV.Vector Double
    doublesProb44 = UV.accum (+) (UV.replicate 9 0.0) [(2, 1.0), (8, 1.0), (4, 1.0/3), (6, 1.0/3)]
    probs44For2To8 = map (\x -> fromIntegral x * probEachDiceConfig44) distinct44RollsFor2To8
    distinct44RollsFor2To8 = [1,2,3,4,3,2,1] :: [Int]
    probEachDiceConfig44 = 1.0 / (4.0 * 4.0)

-- I figured out that rect(n,m) = n*(n+1)*m*(m+1)/4.  Then try all possibilities up to a bit over
-- 2,000,000.

prob085 :: Word
prob085 = fst $ foldl' accumClosestTo2Mill (0, 2000000) values
  where
    values :: [(Word, Word)]
    values = concat [
               takeWhile (\(_, r) -> r < 2001000)
                         [(n*m, rects) | m <- [1..(n `quot` 2)],
                                         let rects = n1 * m * (m + 1) `quot` 4]
                      | n <- [1..2000], let n1 = n * (n + 1)]
    accumClosestTo2Mill :: (Word, Word) -> (Word, Word) -> (Word, Word)
    accumClosestTo2Mill (accProd, accDiff) (currProd, currRects)
      | newDiff < accDiff = (currProd, newDiff)
      | otherwise = (accProd, accDiff)
      where newDiff = abs (2000000 - currRects)

prob086 :: Int
prob086 = binarySearch 20 2000
  where
    goalSolutions = 1000000
    binarySearch :: Int -> Int -> Int
    binarySearch lowTry highTry = binarySearch' (lowTry, lowResult) (highTry, highResult)
      where
        lowResult  = computeDistinctCuboidsForMaxWallSize lowTry
        highResult = computeDistinctCuboidsForMaxWallSize highTry
        binarySearch' :: (Int, Int) -> (Int, Int) -> Int
        binarySearch' (low, lowRes) (high, highRes)
          | low + 1 == high = high
          | midRes > goalSolutions = binarySearch' (low, lowRes) (mid, midRes)
          | otherwise = binarySearch' (mid, midRes) (high, highRes)
          where
            mid = (low + high) `div` 2
            midRes = computeDistinctCuboidsForMaxWallSize mid
    computeDistinctCuboidsForMaxWallSize maxSize = distinctCuboidsUpToMax
      where
        distinctCuboidsUpToMax = foldl' countCuboidsPerPythagTriple 0 relevantPythagTriples
        relevantPythagTriples = pythagoreanTriplesPrimTree (limiter maxSize)
        limiter len (a, b, _)
          = (a <= len && (b `quot` 2) <= len) || (b <= len && (a `quot` 2) <= len)
        countCuboidsPerPythagTriple :: Int -> (Int, Int, Int) -> Int
        countCuboidsPerPythagTriple acc (a, b, _) = acc + countFromMinLeg + countFromMaxLeg
          where
            minLeg = min a b
            maxLeg = max a b
            countFromMinLeg = if maxLeg <= maxSize then minLeg `quot` 2 else 0
            countFromMaxLeg = if minLeg + minLeg < maxLeg then 0
                              else ((2 * minLeg - maxLeg) `quot` 2) + 1

prob087 :: Int
prob087 = result
  where
    limit = 50000000
    result = UV.foldl' (\acc x -> if x then acc + 1 else acc) 0 numbersWithProperty
    numbersWithProperty :: UV.Vector Bool
    numbersWithProperty = UV.replicate limit False UV.// zip genListOfAllSums (repeat True)
    genListOfAllSums = do
      a <- (takeWhile (< (limit - 24)) . map (\x -> x * x)) myPrimes
      b <- (takeWhile (< (limit - 16 - a)) . map (\x -> x * x * x)) myPrimes
      c <- (takeWhile (< (limit - a - b)) . map (\x -> x * x * x * x)) myPrimes
      return (a + b + c)

prob088 :: Int
prob088 = (sum . removeDups [] . sort) rawResults
  where

    -- Fill in the answer for 2 by hand, because all of the rest will have at least one 1, so this
    -- allows us to not test for no 1s.

    rawResults = 4 : map findSmallestSetForK [3..12000]

    -- Search for sets of numbers whose product and sum are the same for k elements of the set.
    -- Search with a maximum value starting and 2 and working up until we have a minimum.

    findSmallestSetForK :: Int -> Int
    findSmallestSetForK k = fssfn 2 (maxBound :: Int)
      where
        fssfn largestStart minSum
          | largestStart + kMinusOne > minSum = minSum
          | otherwise = let !nextStart = largestStart + 1
                        in fssfn nextStart
                           (lookForSmaller kMinusOne largestStart largestStart largestStart minSum)
          where !kMinusOne = k - 1

    -- Recursively search for solutions trying to multiply by numbers the current size or smaller
    -- and then add ones at the end to even up.

    lookForSmaller :: Int -> Int -> Int -> Int -> Int -> Int
    lookForSmaller kLeft currNumb currSum currProd minSum
      | sumWithRestOnes < currProd = minSum
      | sumWithRestOnes == currProd = min sumWithRestOnes minSum
      | sumWithRestOnes < (shiftL currProd 1 - 1) = minSum
      | otherwise = foldl' tryNewNumber minSum [2..currNumb]
      where
        !sumWithRestOnes = currSum + kLeft
        kLeftMinusOne = kLeft - 1
        tryNewNumber acc x  = lookForSmaller kLeftMinusOne x (currSum + x) (currProd * x) acc
    
prob089 :: IO Int
prob089 = do
  fileContents <- readFile "prob089_in.txt"
  let originalRomanNumerals = lines fileContents
      correspondingInts = map romanNumeralsToNumber originalRomanNumerals
      optRomanNumbers = map intToOptimalRomanNumerals correspondingInts
      lengthOriginals = (sum . map length) originalRomanNumerals
      lengthOptimized = (sum . map length) optRomanNumbers
  return (lengthOriginals - lengthOptimized)

-- This one is a straightforward process of elimination after generating all of the possibilities.
-- Generate all pairs, then filter them based on certain numbers being there.  In the end, we have
-- each case repeated twice, so divide the number of good pairs by two to get the answer.  This
-- could probably be optimized by filling a boolean array with each set before running the filter,
-- but I don't know that it would make much difference.

prob090 :: Int
prob090 = length filteredPairs `quot` 2
  where
    allSubsetsOfSix = subsetsOfSize 6 "0123456789"
    allPossiblePairsLeastStringFirst = [if d1 < d2 then (d1, d2) else (d2, d1)
                                         | d1 <- allSubsetsOfSix, d2 <- allSubsetsOfSix]
    filteredPairs  = filter allFilters allPossiblePairsLeastStringFirst
    allFilters dicePair = zeroInFirstAnd14InOther dicePair && twentyFive dicePair
                          && eightyOne dicePair && thirtySix dicePair69 && nine dicePair69
                          && sixTeen dicePair69 && sixtyFour dicePair69
      where
        d1 = fst dicePair
        d2 = snd dicePair
        dicePair69 = (d1, d2, ('6' `elem` d1) || ('9' `elem` d1), ('6' `elem` d2) || ('9' `elem` d2))
    zeroInFirstAnd14InOther (d1, d2)
      | head d1 /= '0' = False
      | head d2 /= '0' = ('1' `elem` d2) && ('4' `elem` d2)
      | otherwise = (('1' `elem` d1) || ('1' `elem` d2)) && (('4' `elem` d1) || ('4' `elem` d2))
    twentyFive (d1, d2) = (('2' `elem` d1) && ('5' `elem` d2)) || (('2' `elem` d2) && ('5' `elem` d1))
    eightyOne (d1, d2) = (('8' `elem` d1) && ('1' `elem` d2)) || (('8' `elem` d2) && ('1' `elem` d1))
    thirtySix (d1, d2, d169, d269) = (('3' `elem` d1) && d269) || (('3' `elem` d2) && d169)
    sixtyFour (d1, d2, d169, d269) = (('4' `elem` d2) && d169) || (('4' `elem` d1) && d269)
    sixTeen (d1, d2, d169, d269) = (('1' `elem` d2) && d169) || (('1' `elem` d1) && d269)
    nine (_, d2, d169, d269) = d269 || ((head d2 == '0') && d169)

type P91PointPair = ((Int, Int), (Int, Int))

prob091 :: Int
prob091 = result
  where
    limit = 50

    result = length all90DegreePairs

    -- We generate a list of all pairs of points, which when connected with (0, 0), form a right
    -- triangle.  There are three simple cases that we enumerate first.  1) the 90-degree angle is
    -- at (0, 0) and the other two points are on the X-axis and the Y-axis; 2) the 90-degree angle
    -- is on the X-axis with the third point directly up from it; and 3) the 90-degree angle is on
    -- the Y-axis with the third point directly to the right.

    allSimpleRightTrianglesWithOrigin = ninetyAtZeroPairs ++ ninetyOnXAxis ++ ninetyOnYAxis
    ninetyAtZeroPairs = [((x1, 0),(0, y2)) | x1 <- [1..limit], y2 <- [1..limit]]
    ninetyOnXAxis = [((x1, 0), (x1, y2)) | x1 <- [1..limit], y2 <- [1..limit]]
    ninetyOnYAxis = [((0, y1), (x2, y1)) | y1 <- [1..limit], x2 <- [1..limit]]

    -- Now look for all cases where the 90-degree angle is at a point on neither the X- or
    -- Y-axis. Accumulate them at the front of the list of simple solutions by folding over all
    -- points in range that are not on one of the axes.

    all90DegreePairs = foldl' tryOptionsForAFirstVertex allSimpleRightTrianglesWithOrigin
                              allPossibleNonZeroFirstVertices
    allPossibleNonZeroFirstVertices = [(x1, y1) | x1 <- [1..limit], y1 <- [1..limit]]

    -- Given this zeroth vertex at (0, 0), this function will take in a first vertex, and look for
    -- any second vertices that, paired with the other two, form a 90-degree angle at the first
    -- vertex.  It does this by searching both down and to the right and up and to the left. It does
    -- this examining only the bounding two vertices in a thin swath.  If you drew a line at
    -- 90-degrees both up and down from point 1, the search will bound that line at each step,
    -- thereby reducing the search needed.  At any point along the search if a point is found that
    -- results in a 90-degree angle at point 1, then both points 1 and 2 are added to the
    -- accumulator.

    tryOptionsForAFirstVertex :: [P91PointPair] -> (Int, Int) -> [P91PointPair]
    tryOptionsForAFirstVertex acc (x1, y1) = accWithUpLeftAndDR
      where

        -- We will need the distance from the origin to point 1 in the search.

        x1_d = fromIntegral x1
        y1_d = fromIntegral y1
        len01Sq = x1_d * x1_d + y1_d * y1_d
        len01 = sqrt len01Sq

        -- From the first point, we search down and to the right for a second point resulting in a
        -- 90-degree angle at the first point.  This search function takes two points representing
        -- an inclusive range where an answer could be found.  The initial two points are one below
        -- the first point, and one to the right.  The search function will walk down and right with
        -- successive pairs of points until it either hits the X-axis or goes out of range to the
        -- right.  A similar search is performed moving up and to the left from point 1.

        accWithDR          = searchFor90Degree2ndPoints 1 GT (x1, y1 - 1) (x1 + 1, y1) acc
        accWithUpLeftAndDR = searchFor90Degree2ndPoints (-1) LT (x1, y1 + 1) (x1 - 1, y1) accWithDR

        -- Given a second point, determine if there is a 90-degree angle at point 1, or if the angle
        -- is greater than or less than 90.  Use the law of cosines.

        compareAngleAtFirstPointWith90 :: (Int, Int) -> Ordering
        compareAngleAtFirstPointWith90 (x2, y2)
          | ang1 < (1.5707963267948 :: Double) = LT
          | ang1 > (1.5707963267949 :: Double) = GT
          | otherwise = EQ
          where
            x2_d = fromIntegral x2
            y2_d = fromIntegral y2
            len02Sq = x2_d * x2_d + y2_d * y2_d
            lenX12 = abs (x1_d - x2_d)
            lenY12 = abs (y1_d - y2_d)
            len12Sq = lenX12 * lenX12 + lenY12 * lenY12
            ang1 = acos ((len02Sq - len01Sq - len12Sq) / ((-2) * len01 * sqrt len12Sq))

        -- The caller has defined point 1, and we are given two points that serve as an inclusive
        -- range, here and in further calls, that might include a second point where there will be a
        -- 90-degree angle at point 1 relative to the origin and the second point we are searching
        -- for.  This function either searches down and to the right, in which case the first two
        -- arguments are 1 and GT, or up and to the left, where they are -1 and LT.  The bounding
        -- points are specified next.  If we are searching down and to the right, then the second
        -- bounding point will always be one up and one to the right of the first.  If we are
        -- searching up and to the left, then the second bounding point will always be one down and
        -- one to the left of the first.  This function takes in an accumulator, which it returns
        -- when finished with the search with any discovered results prepended to the front.

        searchFor90Degree2ndPoints :: Int -> Ordering -> (Int, Int) -> (Int, Int)
                                      -> [P91PointPair] -> [P91PointPair]
        searchFor90Degree2ndPoints incX relToY (px1, py1) (px2, py2) innerAcc

          -- If both of the points are out of bounds, then just return the accumulator.

          | xOutOfBounds && yOutOfBounds = innerAcc

          -- If the X-value of the second point is out of range, then check the first point and
          -- either return the accumulator with that point added if it passes, or just the
          -- accumulator.

          | xOutOfBounds = newAccOne

          -- If the Y-value of the first point is out of range, then check the other point and
          -- either return the accumulator with that point added if it passes, or just the
          -- accumulator.

          | yOutOfBounds = newAccTwo

          -- If the center point is an answer, then add it to the accumulator and do a recursive
          -- call with the two appropriate points from there.

          | angleAtOneWRT90Cent == EQ
            = searchFor90Degree2ndPoints incX relToY (cx, cy - incX) (cx + incX, cy)
                                         (((x1, y1), (cx, cy)) : innerAcc)

          -- Since neither point is out of range, test them both for inclusion, then recursively
          -- call this function with the next two points, one of which will be the point next
          -- encountered between the two passed in, and depending on the angle at point one with
          -- the center point. The test and which to use depend on which direction the search is.

          | angleAtOneWRT90Cent == relToY
            = searchFor90Degree2ndPoints incX relToY (px1, py1 - incX) centerPtOfNext newAccBoth
          | otherwise
            = searchFor90Degree2ndPoints incX relToY centerPtOfNext (px2 + incX, py2) newAccBoth
          where
            xOutOfBounds = px2 < 0 || px2 > limit
            yOutOfBounds = py1 < 0 || py1 > limit
            angleAtOneWRT90Cent = compareAngleAtFirstPointWith90 centerPtOfNext
            centerPtOfNext@(cx, cy) = (px2, py1)
            newAccOne  = testPointFor90AndAddToAccum (px1, py1) innerAcc
            newAccTwo  = testPointFor90AndAddToAccum (px2, py2) innerAcc
            newAccBoth = testPointFor90AndAddToAccum (px2, py2) newAccOne

        -- If the point passed in results in a 90-degree angle at point 1, then add these two
        -- points to the accumulator that was passed in, otherwise just return the accumulator.

        testPointFor90AndAddToAccum :: (Int, Int) -> [P91PointPair] -> [P91PointPair]
        testPointFor90AndAddToAccum (px, py) acc'
          | compareAngleAtFirstPointWith90 (px, py) /= EQ = acc'
          | otherwise = ((x1, y1), (px, py)) : acc'

-- I discovered something so cool when working on this problem and looking at another Haskell
-- solution after I had solved it in C++.  I have had some trouble with arrays in Haskell, and know
-- that modifying them once created is difficult and awkward.  I wanted to create an array from 1 to
-- 569 (only need to 7 * 81, but going to 569 allows an optimization later) that I could set to 0
-- and then populate in a kind of random fashion.  I could do it by unthawing the array, but that
-- isn't very Haskell-like.  I couldn't see a way to initialize them with the right values because
-- you don't know the order.  After looking at someone else's solution, I realized that I can
-- initialize the values with indexes into other parts of the array, but because of lazy evaluation,
-- they don't get computed until you need them.  when you finally do use one, it will jump around
-- initializing any number of array elements, as long as it eventually ends up at 1 or 89, which it
-- always will.
--
-- The idea here is to first populate an array from 1 to 999, which is unboxed as described above.
-- We only need to go to 567 to cover all possible sums of squared digits up to 9,999,999, but by
-- going to 999, we can optimize for the rest.  Then go from 1000 to 9,999,000 stepping by 1000, get
-- the sum of the squared digits of this number and then for each of the 1000 starting from there,
-- add a pre-computed value which is the sum of the squares of the digits for 0 to 999.  We look up
-- the result in the boxed array we computed before to count the ones that cycle down to 89.

prob092 :: Int
prob092 = countInInitialArray + countAfterArray
  where
    countInInitialArray = length $ filter (settlesTo89 BA.!) [1..999]
    countAfterArray = countSettlesTo89 [1000,2000..9999000] 0
    squaredLastThree :: UV.Vector Int
    squaredLastThree = UV.fromList [sumDigSq x | x <- [0..999]]
    settlesTo89 :: BA.Array Int Bool
    settlesTo89 = BA.array (1,999) ((1, False) : (89, True)
        : [(i, settlesTo89 BA.! sumDigSq i) | i <- [2..999], i /= 89])
    sumDigSq :: Int -> Int
    sumDigSq val = foldl' squareDigitAndAdd 0 (show val)
    squareDigitAndAdd acc x = let xI = digitToInt x
                              in acc + xI * xI
    countSettlesTo89 :: [Int] -> Int -> Int
    countSettlesTo89 [] count = count
    countSettlesTo89 (x:xs) count
      = countSettlesTo89 xs (count + settleAt89ForTheseThousand)
      where
        !sumAtThousand = sumDigSq x
        settleAt89ForTheseThousand = foldl' sum89s 0 [0..999]
        sum89s :: Int -> Int -> Int
        sum89s acc y
          = let sumOfSquareLast3Digits = squaredLastThree UV.! y
                sumOfSquareAllDigits = sumAtThousand + sumOfSquareLast3Digits
                is89 = settlesTo89 BA.! sumOfSquareAllDigits
            in if is89 then acc + 1 else acc

prob093 :: Int
prob093 = maxFourDigitNumber
  where
    maxFourDigitNumber = (read . map intToDigit) (snd maxOne)
    maxOne = head sortedByMax
    sortedByMax = sortBy (flip compare) maxRunsWithDigits
    maxRunsWithDigits = zip (map findMaxRun arithResults) setsOfFourDigits
    arithResults = map (filter (\(x, _) -> x > 0) . allArithPerms) setsOfFourDigits
    setsOfFourDigits = subsetsOfSize 4 [0,1,2,3,4,5,6,7,8,9]

    -- Function that takes a list of pairs with the result of the arithmetic and the list of
    -- expression strings that result in that number. It uses just the result of the arithmetic, and
    -- zips the list together with itself offset by one, then subtracts one from the other.  Where
    -- the resulting list has a 1, there were two consecutive results.  Group these, then count the
    -- length (drop those that aren't one), and then add one to get the length of a run.  Take the
    -- maximum.

    findMaxRun :: [(Int, [String])] -> Int
    findMaxRun sortedResultList = maxRun
      where
        maxRun = 1 + (maximum . map length . filter (\x -> head x == 1) . group) diffValues
        diffValues = zipWith (-) (tail justSortedValues) justSortedValues
        justSortedValues = map fst sortedResultList

-- After solving this problem with the solution in prob094a and looking at the comment thread for
-- the problem, I understood that when generating pythagorean triples, we can greatly reduce the
-- number to look at by recognizing that ones that result in a solution have the hypotenuse equal to
-- (2a +- 1) or (2b +- 1).  Here is a special version of primitive pythagorean generation that will
-- only generate these, and that speeds things up by a giant factor (10^6).  The filtering isn't
-- even needed, although I left it in anyway.

prob094 :: Int
prob094 = result
  where
    perimeterLimit = 1000000000
    result = (sum . map perimeter . filter correctDimensions . map hypotenuseAndShortest)
             (primitivePythagoreanTriplesSubsetr (fullTriangleWithinLimit perimeterLimit))
    fullTriangleWithinLimit perim (a,b,c)
      | a < b = 2*a+2*c <= perim
      | otherwise = 2*b+2*c <= perim
    hypotenuseAndShortest (a, b, c) = if a < b then (a, c) else (b, c)
    correctDimensions :: (Int, Int) -> Bool
    correctDimensions (a, c) = let aTimes2 = a + a in aTimes2 == c + 1 || aTimes2 == c - 1
    perimeter (a, c) = a + a + 2 * c
    primitivePythagoreanTriplesSubsetr :: ((Int, Int, Int) -> Bool) -> [(Int, Int, Int)]
    primitivePythagoreanTriplesSubsetr limitFunc = ptpt [(3, 4, 5)]
      where
        ptpt :: [(Int, Int, Int)] -> [(Int, Int, Int)]
        ptpt [] = []
        ptpt ((a,b,c):pts)
          | limitFunc (a,b,c) = (a,b,c) : ptpt newPTS
          | otherwise = ptpt pts
          where
            newPTS = if a < b then nextPrimC : pts else nextPrimA : pts
            nextPrimA = (a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c)
            nextPrimC = ((-a) + 2*b + 2*c, (-2)*a + b + 2*c, (-2)*a + 2*b + 3*c)

-- This is much faster than the graph-based solution below.  It could be faster still if it updated
-- the vector of visited numbers using non-functional updates.

prob095 :: Int
prob095 = minimum loop
  where
    limit = 1000000
    cntUntilUpdateVisited = 1000  -- This seems about the optimal number before updating bit vector.
    properFactorSumList = map (\(a, b) -> (fromIntegral a :: Int, fromIntegral b :: Int))
                          (listOfProperFactorSumsToLimit64 (fromIntegral limit))
    properFactorSumVec = UV.accum (+) (UV.replicate (limit + 1) 0) properFactorSumList
    ((_, loop), _) = UV.ifoldl' lookForLongestCycle
                       ((0, []), (cntUntilUpdateVisited, UV.replicate (limit + 1) False, []))
                       properFactorSumVec
    lookForLongestCycle :: ((Int, [Int]), (Int, UV.Vector Bool, [Int])) -> Int -> Int
                           -> ((Int, [Int]), (Int, UV.Vector Bool, [Int]))
    lookForLongestCycle acc@((accLen, accLoop), (bvCount, visited, visitedList)) ind val

      -- If we have hit the limit of iterations before updating the visited boolean vector, update
      -- it and continue with the new one. We balance the frequency of doing this so that the cost
      -- of updating is worth the savings from being able to reference the updates.

      | bvCount == 0 = lookForLongestCycle accUpdatedForVisited ind val

      -- If we have already visited this index in a prior loop, then just continue with the same
      -- accumulator.

      | UV.unsafeIndex visited ind = acc

      -- If the value is greater than the limit, then this doesn't have a loop in the range, so add
      -- the index to the list of visited and continue.

      | (val > limit) || (val == 1)
        = let !newBV = bvCount - 1
              !newVis = ind : visitedList
          in ((accLen, accLoop), (newBV, visited, newVis))

      -- Pursue the series of numbers from this index on, and see if there is a loop.  If so,
      -- replace the accumulated longest loop with it if it is longer.

      | otherwise = let !(newLen, newLoop) = if foundLoopLen > accLen then (foundLoopLen, foundLoop)
                                                                      else (accLen, accLoop)
                        !newBV = bvCount - 1
                    in ((newLen, newLoop), (newBV, visited, furtherIndexesVisited))
      where

        -- Update the visited boolean vector for any indices visited since the last update.
        
        accUpdatedForVisited = ((accLen, accLoop), (cntUntilUpdateVisited, newVisited, []))
        newVisited = UV.unsafeUpd visited (zip visitedList (repeat True))

        -- Search from this index for a loop.  Add visited indexes to a list, and if a loop is
        -- found, return the length and the loop numbers.

        (foundLoopLen, foundLoop, indexesVisited) = searchForLoopFromHere ind []
        furtherIndexesVisited = foldl' (flip (:)) visitedList indexesVisited

        -- The search function.

        searchForLoopFromHere :: Int -> [Int] -> (Int, [Int], [Int])
        searchForLoopFromHere ind' visitedSoFar

          -- If the current index is over the limit or we have visited this one before, then no loop
          -- was found, so just return all of the indexes visited from this point.

          | ind' > limit || UV.unsafeIndex visited ind' = (0, [], visitedSoFar)

          -- If we have seen this index before in this search, then we have found a loop.  Return
          -- the length of the loop, the loop itself, and the indexes visited in this search.

          | ind' `elem` visitedSoFar = (loopLength, loopList, visitedSoFar)

          -- Continue the search with the next value from the array.

          | otherwise = let !newVis = ind' : visitedSoFar
                            !newInd = UV.unsafeIndex properFactorSumVec ind'
                        in searchForLoopFromHere newInd newVis
          where

            -- Get the list of indexes in the loop, and note that it's not necessarily the whole
            -- list.

            loopList = ind' : takeWhile (/= ind') visitedSoFar
            loopLength = length loopList
                                     
-- Types used for the Sudoku solver.  Use 8 bit and 16 bit integers when possible to reduce the
-- amount of copying needed when updating vectors.

type SKBoardElement = Int8
type SKBoard = UV.Vector SKBoardElement
type SKUsed = Int16
type SKUsedVec = UV.Vector SKUsed
type SKConvert = Int
type SKConvertVec = UV.Vector SKConvert
type SKBoardState = (SKBoard, SKUsedVec, SKUsedVec, SKUsedVec)

-- Use these vectors to quickly convert from a square index in the board to a row, column, or block
-- index.

skIndexToRow :: SKConvertVec
skIndexToRow   = UV.fromList (concatMap (replicate 9) [0..8])
skIndexToCol :: SKConvertVec
skIndexToCol   = UV.fromList [x `rem` 9 | x <- [0..80]]
skIndexToBlock :: SKConvertVec
skIndexToBlock = UV.fromList (concatMap (replicate 3) (concat (concatMap (replicate 3)
                                       [[0,1,2],[3,4,5],[6,7,8]])))

-- Solve a single Sudoku puzzle, the input being a string of 81 digits representing the puzzle, with
-- 0s for the unknown values.  The output will be a list of strings with all solutions to the
-- puzzle.  Error checking of the input string is expected to be done prior to the calling of this
-- function.

solveSudoku :: String -> [String]
solveSudoku inputPuzzle = solution
  where

    -- Map the string input into an 81-element vector representing the board.  Populate bit masks
    -- indicating which numbers are used in which rows, columns, and blocks.  Create a list of the
    -- indexes of squares with unknown values.
    
    startBoard = UV.fromList (map (fromIntegral . digitToInt) inputPuzzle) :: SKBoard
    (usedInRow, usedInCol, usedInBlock)
      = populateUsedInRowColBlock startBoard :: (SKUsedVec, SKUsedVec, SKUsedVec)
    initialBoardState = (startBoard, usedInRow, usedInCol, usedInBlock)
    empties = genEmpties startBoard

    -- Go through the starting board and search for unknown values that can only be one choice given
    -- the contents of their row, column, and block.  Set these, recalculate the used bit masks, and
    -- repeat until there are no more unknown values left or we can no longer find any values that
    -- have only one choice.
    
    (partiallySolvedState, remainingEmpties) = lockInDeducableChoices initialBoardState empties

    -- Once we have filled in all of the squares that are deducable, do a depth-first search on the
    -- rest given the possible values that remain for each empty square.

    sortedEmpties = optimizeDFSSearchOrder partiallySolvedState remainingEmpties    
    solution = solveSudokuDFS partiallySolvedState sortedEmpties []

    -- Try to improve the search order so that squares with fewer options are visited earlier. This
    -- is tricky because to do it right, we need to find the best first square to try, and then find
    -- the best one after that assuming the first square is set, etc.

    optimizeDFSSearchOrder :: SKBoardState -> [Int] -> [Int]
    optimizeDFSSearchOrder _ [] = []
    optimizeDFSSearchOrder (board, _, _, _) emptySquares = optOrder
      where
        optOrder = dynamicallyFindBestOrder emptiesAndCounts []
        (rowCounts, colCounts, blockCounts) = populateCountInRowColBlock board
        emptiesAndCounts = sortBy bigCountsFirst $ map addCounts emptySquares

        -- Find optimal search order.  We sorted the list of open squares based on the sum of the
        -- filled row, column, and block squares associated with each empty square.  This function
        -- will then walk down the list, putting the head index on the accumulator, and reordering
        -- the remainder of the list based on the current square being filled.

        dynamicallyFindBestOrder :: [(Int, Int)] -> [Int] -> [Int]
        dynamicallyFindBestOrder [] acc = reverse acc
        dynamicallyFindBestOrder ((ind, _) : rest) acc
          = dynamicallyFindBestOrder reorderedRest (ind : acc)
          where
            reorderedRest = sortBy bigCountsFirst $
                            map bumpCountAppropriately rest
            !(rowIndex, colIndex, blockIndex) = calcRCBIndices ind

            -- Add one for each common row, column, and block with the index just taken off the top
            -- of the list.

            bumpCountAppropriately :: (Int, Int) -> (Int, Int)
            bumpCountAppropriately (ind', count) = (ind', newCount)
              where
                newCount = count + incRow + incCol + incBlock
                incRow   = if rowIndex == rowIndex' then 1 else 0
                incCol   = if colIndex == colIndex' then 1 else 0
                incBlock = if blockIndex == blockIndex' then 1 else 0
                !(rowIndex', colIndex', blockIndex') = calcRCBIndices ind'

        -- Sort pairs based on larger counts first, secondarily the index.

        bigCountsFirst :: (Int, Int) -> (Int, Int) -> Ordering
        bigCountsFirst (ind1, cnt1) (ind2, cnt2)
          | cnt2 < cnt1 = LT
          | cnt2 > cnt1 = GT
          | otherwise = compare ind1 ind2

        -- Pair the count of the number of set values in each square's row, column, and block

        addCounts :: Int -> (Int, Int)
        addCounts ind = (ind, fromIntegral countAll)
          where
            !countAll       = countRowCol + countBlock
            !countRowCol    = countRow + countCol
            !countRow       = rowCounts UV.! rowIndex
            !countCol       = colCounts UV.! colIndex
            !countBlock     = blockCounts UV.! blockIndex
            !(rowIndex, colIndex, blockIndex) = calcRCBIndices ind

        -- Populate vectors for rows, columns, and blocks that are just the counts of squares set.

        populateCountInRowColBlock :: SKBoard -> (SKUsedVec, SKUsedVec, SKUsedVec)
        populateCountInRowColBlock board'
          = (UV.generate 9 (\rowInd -> genCount [(rowInd * 9)..((rowInd + 1) * 9 - 1)]),
             UV.generate 9 (\colInd -> genCount [x + colInd | x <- [0,9..72]]),
             UV.generate 9 (\blockInd -> genCount [x | x <- [0..80],
                                     UV.unsafeIndex skIndexToBlock x == blockInd]))
          where
        
            -- Count the number set in the group.

            genCount :: [Int] -> SKUsed
            genCount = foldl' countValues 0

            countValues :: SKUsed -> Int -> SKUsed
            countValues acc boardIndex = let boardValue = board' UV.! boardIndex
              in if boardValue /= 0 then acc + 1 else acc

    -- Generate the list of empty squares in the current board.

    genEmpties :: SKBoard -> [Int]
    genEmpties = UV.ifoldl' (\acc ind val -> if val == 0 then ind : acc else acc) []

    -- From a square index, look up and return the row, column, and block indices.

    calcRCBIndices :: Int -> (Int, Int, Int)
    calcRCBIndices ind
      = (skIndexToRow UV.! ind, skIndexToCol UV.! ind, skIndexToBlock UV.! ind)

    -- Lock in the squares where there is only a single possibility that is deducable, and repeat
    -- until there are no more single possibilities.

    lockInDeducableChoices :: SKBoardState -> [Int] -> (SKBoardState, [Int])
    lockInDeducableChoices boardState emptySquares
      | numberSet == 0 || null newEmpty = (newBoardState, newEmpty)
      | otherwise = lockInDeducableChoices newBoardState newEmpty
      where
        (newBoardState, newEmpty, numberSet)
          = findAndSetSingleOptionSquares boardState emptySquares
    
    -- Take in a board state and the list of empty square indexes, find the squares that only have
    -- one choice possible, create a new board state with these set, and return it and the remaining
    -- list of empty square indexes.

    findAndSetSingleOptionSquares :: SKBoardState -> [Int] -> (SKBoardState, [Int], Int)
    findAndSetSingleOptionSquares boardState@(currBoard, _, _, _) emptySquares
      = (newerBoardState, remainingEmpties'', numberSet)
      where

        -- Search for the simplest ones to set, where there is only one option for a square given
        -- the values set in its row, column, and block.  Set any of these and create a new board
        -- and new used vectors.
        
        (simplePairs, remainingEmpties', simplesSet)
          = findSimpleOptions emptySquares [] [] 0
        newBoard = currBoard UV.// simplePairs
        (newUsedRow, newUsedCol, newUsedBlock) = populateUsedInRowColBlock newBoard
        newBoardState = (newBoard, newUsedRow, newUsedCol, newUsedBlock)

        -- Now search for a more complicated situation where there is only one option for a square.
        -- This is the case where when considering a row, column, or block there is only one square
        -- where a particular number is an option.

        newerBoard = newBoard UV.// otherSinglePairs
        (newerUsedRow, newerUsedCol, newerUsedBlock) = populateUsedInRowColBlock newerBoard
        newerBoardState = (newerBoard, newerUsedRow, newerUsedCol, newerUsedBlock)
        remainingEmpties'' = genEmpties newerBoard
        othersSet = length otherSinglePairs
        numberSet = simplesSet + othersSet

        -- Generate the new options list based on the board with the ones filled in where there is
        -- only one option.  From this, generate three lists sorted by the respective RCB index,
        -- that hold triples of the RCB index, the board index, and the list of possible values for
        -- that square, based on the values used in the corresponding row, column, and block.

        newerOptions      = genListValidChoices newBoardState remainingEmpties'
        newerRowOptions   = reconfigureForRCB (UV.unsafeIndex skIndexToRow) newerOptions
        newerColOptions   = reconfigureForRCB (UV.unsafeIndex skIndexToCol) newerOptions
        newerBlockOptions = reconfigureForRCB (UV.unsafeIndex skIndexToBlock) newerOptions

        rowSingles       = findOtherOnlyOptions [] newerRowOptions
        rowColSingles    = findOtherOnlyOptions rowSingles newerColOptions
        allSingles       = findOtherOnlyOptions rowColSingles newerBlockOptions
        otherSinglePairs = map head $ group $ sort allSingles

        -- Function to take a list of the options for each empty square, and reconfigure the data so
        -- it can be analyzed for deducable values.

        reconfigureForRCB :: (Int -> Int) -> [(Int, [SKBoardElement])]
                              -> [(Int, [(Int, Int)])]
        reconfigureForRCB rcbIndexFn optionList
          = convertToVecInit [] $ sortBy compareRCBIndex $
            map (addRCBIndex rcbIndexFn) optionList
        
        -- Add all of the values associated with a RCB index into a vector indexed by the option
        -- number.  When done, if any of the option numbers has only one value, then that is the
        -- only choice, so add it to the list of value to set.

        findOtherOnlyOptions :: [(Int, SKBoardElement)] -> [(Int, [(Int, Int)])]
                                -> [(Int, SKBoardElement)]
        findOtherOnlyOptions acc [] = acc
        findOtherOnlyOptions acc ((_, initList) : xs)
          = findOtherOnlyOptions newAccum xs
          where
            newAccum = UV.ifoldl' accumSingleUses acc usedOptionsVec
            usedOptionsVec = UV.accum (+) (UV.replicate 10 0) initList
            accumSingleUses :: [(Int, SKBoardElement)] -> Int -> Int
                               -> [(Int, SKBoardElement)]
            accumSingleUses accum' ind value
              = if singleUse then (bdIndex, fromIntegral ind) : accum' else accum'
              where
                bdIndex = shiftR value 4
                !singleUse = (value .&. 0xF) == 1

        -- Convert a sorted list of triples (rcb, board index, [options]) to a list of: (rcb,
        -- [(option, value)] where value is the board index shifted left by 4 anded with 0x1.  These
        -- will later be used to sum for the rcb based on the option to find individual options that
        -- can only go one place in the row, column, or block.  The first parameter is the
        -- accumulator and [] should be passed in when called.

        convertToVecInit :: [(Int, [(Int, Int)])] -> [(Int, Int, [SKBoardElement])]
                            -> [(Int, [(Int, Int)])]
        convertToVecInit acc [] = acc
        convertToVecInit acc ((rcb, bdInd, options) : xs)
          | null options = convertToVecInit acc xs
          | null acc || currAccRCB /= rcb
            = convertToVecInit ((rcb, [(firstOption, value)]) : acc)
                               inputWithRemovedOption
          | otherwise
            = convertToVecInit ((currAccRCB, (firstOption, value) : currAccPairs) : accums)
                               inputWithRemovedOption
          where
            currAccRCB = fst $ head acc
            currAccPairs = snd $ head acc
            accums = tail acc
            firstOption = fromIntegral $ head options
            value = shiftL bdInd 4 .|. 0x1
            inputWithRemovedOption = (rcb, bdInd, tail options) : xs
        
        -- Comparison function for sorting based on row, column, or block index in the first
        -- position of the tuple, and secondly on the board index.

        compareRCBIndex :: (Int, Int, [SKBoardElement])
                           -> (Int, Int, [SKBoardElement]) -> Ordering
        compareRCBIndex (rcb1, bdInd1, _) (rcb2, bdInd2, _)
          = if compRCB == EQ then compare bdInd1 bdInd2 else compRCB
          where !compRCB = compare rcb1 rcb2

        -- Map function to convert an (Int, [SKBoardElement]) pair to (Int, Int, [SKBoardElement])
        -- where the first member of the resulting tuple is the row, column, or block index.  The
        -- second is the board index.  The list is still the possible options for that square.

        addRCBIndex :: (Int -> Int) -> (Int, [SKBoardElement])
                         -> (Int, Int, [SKBoardElement])
        addRCBIndex convFuncRCB (ind, options) = (convFuncRCB ind, ind, options)

        -- Go through the empty squares and accumulate a list of the ones that can be filled with a
        -- single value, and the remaining empty ones that can't.  Count the ones that can be filled
        -- with a single value and return that along with the two lists.

        findSimpleOptions :: [Int] -> [Int] -> [(Int, SKBoardElement)] -> Int ->
                             ([(Int, SKBoardElement)], [Int], Int)
        findSimpleOptions [] emptySquares' singlePairs' numberSet'
          = (singlePairs', emptySquares', numberSet')
        findSimpleOptions (ind : indexes) emptySquares' singlePairs' numberSet'
          | null currOptions = ([], [], 0)
          | null (tail currOptions)
            = findSimpleOptions indexes emptySquares'
                                ((ind, head currOptions) : singlePairs') (numberSet' + 1)
          | otherwise
            = findSimpleOptions indexes (ind : emptySquares') singlePairs' numberSet'
          where
            currOptions = genValidChoices boardState ind

    -- Given a board, set the bits in the row, col, and block vectors to indicate what values are
    -- used in each row, column, and block.

    populateUsedInRowColBlock :: SKBoard -> (SKUsedVec, SKUsedVec, SKUsedVec)
    populateUsedInRowColBlock board
      = (UV.generate 9 (\rowInd -> orValues [(rowInd * 9)..((rowInd + 1) * 9 - 1)]),
         UV.generate 9 (\colInd -> orValues [x + colInd | x <- [0,9..72]]),
         UV.generate 9 (\blockInd -> orValues [x | x <- [0..80],
                                     UV.unsafeIndex skIndexToBlock x == blockInd]))
      where
        
        -- OR together the board values given by the list of indices.

        orValues :: [Int] -> SKUsed
        orValues = foldl' orInValueIfNonZero 0

        -- The first argument is the accumulator and the second is the board index.  If the value on
        -- the board is non-zero, then set the bit corresponding to that value in the accumulator.

        orInValueIfNonZero :: SKUsed -> Int -> SKUsed
        orInValueIfNonZero acc boardIndex = let boardValue = board UV.! boardIndex
          in if boardValue /= 0
             then acc .|. shiftL 0x1 (fromIntegral boardValue)
             else acc

    -- Generate valid choices for a list of squares, returning a list of pairs.

    genListValidChoices :: SKBoardState -> [Int] -> [(Int, [SKBoardElement])]
    genListValidChoices board = map (\ind -> (ind, genValidChoices board ind))

    -- Given a board and an index, return a list of the valid values that may be used there.  This
    -- is done by using the combination of used in row, column, and block for the given index.

    genValidChoices :: SKBoardState -> Int -> [SKBoardElement]
    genValidChoices (_, usedRow, usedCol, usedBlock) ind
      = [x | x <- [1..9], testBit validChoiceBits (fromIntegral x)]
      where
        !validChoiceBits = complement (usedInRow' .|. usedInCol' .|. usedInBlock')
        !(rowIndex, colIndex, blockIndex) = calcRCBIndices ind
        !usedInRow'   = usedRow UV.! rowIndex
        !usedInCol'   = usedCol UV.! colIndex
        !usedInBlock' = usedBlock UV.! blockIndex

    -- Do a depth-first search for solutions given the board state, and list of empty square
    -- indexes.  If there are no more empty square indexes, then we have a solution, so convert it
    -- to a string and return it.  Otherwise, for each empty square try each possible value and
    -- recursively call this function given each of those options.  Concatenate any solutions found
    -- together and return them.

    solveSudokuDFS :: SKBoardState -> [Int] -> [String] -> [String]
    solveSudokuDFS (currBoard, _, _, _) [] solsSoFar
      = UV.foldr (\x acc -> intToDigit (fromIntegral x) : acc) [] currBoard : solsSoFar
    solveSudokuDFS boardState@(currBoard, usedRow, usedCol, usedBlock) (ind : rest) solsSoFar
      = concatMap setCurrAndRecurse validChoices ++ solsSoFar
      where
        validChoices = genValidChoices boardState ind

        -- For a given choice for the current square, recursively call this function with
        -- appropriately set used and board vectors.

        setCurrAndRecurse :: SKBoardElement -> [String]
        setCurrAndRecurse value
          = solveSudokuDFS (currBoard UV.// [(ind, value)],
                            usedRow   UV.// [(rowIndex, newRowVal)],
                            usedCol   UV.// [(colIndex, newColVal)],
                            usedBlock UV.// [(blockIndex, newBlockVal)])
                           rest []
          where
            !(rowIndex, colIndex, blockIndex) = calcRCBIndices ind
            !newRowVal   = setBit (UV.unsafeIndex usedRow rowIndex) (fromIntegral value)
            !newColVal   = setBit (UV.unsafeIndex usedCol colIndex) (fromIntegral value)
            !newBlockVal = setBit (UV.unsafeIndex usedBlock blockIndex) (fromIntegral value)

prob096 :: IO Int
prob096 = do
  fileContents <- readFile "prob096_in.txt"
  let
    allSudokuAnswers = solveAllSudokus fileContents
    sumOfFirstThreeDigits = foldl' sumFirstThreeDigits 0 allSudokuAnswers

  return sumOfFirstThreeDigits
  where

    -- This will sum the first three digits of the solutions, interpreted as a three-digit number.
    -- It assumes that there is exactly one solution for each puzzle.
    -- The additional patterns are needed to get rid of compiler warnings.

    sumFirstThreeDigits :: Int -> [String] -> Int
    sumFirstThreeDigits acc solution
      | null solution || null first = acc
      | length first < 3 = acc
      | otherwise = acc + digitToInt c + digitToInt b * 10 + digitToInt a * 100
      where
        (first : _) = solution
        (a : b : c : _) = first

    -- Solve all Sudoku puzzles given in the input string.  These are converted first to a single
    -- string per puzzle, then solved giving a list of solutions for each.

    solveAllSudokus :: String -> [[String]]
    solveAllSudokus allPuzzles = allSolutions
      where
        listOfPuzzles = fst $ foldl reconfigureInput ([], 0) (lines allPuzzles)
        allSolutions = map solveSudoku listOfPuzzles

        -- Convert the input which is arranged in lines of nine digits with a header for
        -- each puzzle into a string of 81 digits per string.
        
        reconfigureInput :: ([String], Int) -> String -> ([String], Int)
        reconfigureInput (xs, 0) _ = (xs, 1)
        reconfigureInput (xs, 1) str = (str : xs, 2)
        reconfigureInput ([], _) _ = error "Error: Bad index in Problem 96."
        reconfigureInput (x : xs, ind) str
          = ((x ++ str) : xs, if ind == 9 then 0 else ind + 1)

prob097 :: Integer
prob097 = (28433 * 2^(7830457 :: Integer) + 1) `rem` 10000000000

prob098 :: IO Int
prob098 = do
  fileContents <- BC.readFile "prob098_in.txt"
  let

    -- Look for the maximum square among the set of answers with the longest words.  Shorter words
    -- will result in smaller numbers and we're looking for the largest, so no need to look further
    -- than those answers with the longest length.

    maxSolution = foldl' (\acc (n1, _, n2, _) -> maximum [acc, n1, n2]) 0
                  (takeWhile (\(_, nm, _, _) -> BC.length nm == longestLength) solutions)
    longestLength = if null solutions then 0 else let (_, nm, _, _) = head solutions in BC.length nm
    solutions = scanForSolutions [] onlyAnagramPairs
    onlyAnagramPairs = keepOnlyAnagrams sortedLetterNamePairs False

    -- Sort all of the words, first by length (longest to shortest, which is used to only process as
    -- many as we need to get the solution), then by sorted letters in the word.  Once the sorting
    -- is done, remove the length.

    sortedLetterNamePairs
      = (map (\(_, s1, s2) -> (s1, s2)).  sort . map (\name -> (-(BC.length name), BC.sort name, name)))
        names

    -- Function defined above to separate all of the words in the format the file is in.  Names will
    -- have the list of all of the words in the file.
    
    (names, _, _) = BC.foldl' parseWordsFromString ([], [], False) fileContents

  return maxSolution
  where
    squaresVec = V.fromList ([] : genSquareStrs 1 10 1000000000 [] [])

    -- Work though the sorted list pair by pair and if the first two have the same characters, look
    -- for mappings that are anagramic square pairs.

    scanForSolutions :: [(Int, BC.ByteString, Int, BC.ByteString)] -> [(BC.ByteString, BC.ByteString)]
                        -> [(Int, BC.ByteString, Int, BC.ByteString)]
    scanForSolutions acc [] = acc
    scanForSolutions acc [_] = acc
    scanForSolutions acc ((firstChars, firstWord) : (secondChars, secondWord) : xs)

      -- If the first and second sets of characters in the list are not the same, then these two
      -- aren't anagrams, and we can continue with the tail of the list.

      | firstChars /= secondChars = scanForSolutions acc remainderOfInput

      -- If the first and second sets of characters are the same, then see if this pair corresponds
      -- to one or more solution, and if so, append to the accumulator.

      | otherwise = scanForSolutions (acc ++ validSquares) remainderOfInput
      where
        remainderOfInput = (secondChars, secondWord) : xs
        wordLen = BC.length firstWord

        -- Get the list of potential squares that this word could map to based on the length of the
        -- word.

        possibleSquares = squaresVec V.! wordLen

        -- Go through the list of squares of the right length, and see which ones can map to both
        -- the first and second words, and return the words along with the corresponding squares.
        -- There may be more than one valid pair of squares, and often there are two mappings that
        -- are mirrors of each other.

        validSquares = foldl' checkForValidSquare [] possibleSquares
        checkForValidSquare :: [(Int, BC.ByteString, Int, BC.ByteString)] -> BC.ByteString
                               -> [(Int, BC.ByteString, Int, BC.ByteString)]
        checkForValidSquare accm squareStr
          | validFirstMapping && secondPotSquareNotZeroPrefix && secondMapIsSquare
              = (read (BC.unpack squareStr), firstWord, secondPotSquare, secondWord) : accm
          | otherwise = accm
          where

            -- Try the current square with the first word, see if we have a valid mapping, and if so
            -- get the map representing the mapping.  Check it with the second word, then if that
            -- works, make sure the resulting integer doesn't have a leading zero and is a square.
            -- If so, then this is a solution.

            (validFirstMapping, firstMapping)
              = foldl' addCharFirst (True, M.empty) (BC.zip squareStr firstWord)
            secondPotSquare = BC.foldl' checkAndAccumSecond 0 secondWord
            iSquareRootSecond = isqrtInt secondPotSquare
            secondPotSquareNotZeroPrefix = length (show secondPotSquare) == wordLen
            secondMapIsSquare = (iSquareRootSecond * iSquareRootSecond) == secondPotSquare
            ord0 = ord '0'

            -- Used to go through each digit of the square and each character of the first word in
            -- parallel.

            addCharFirst :: (Bool, M.Map Char Char) -> (Char, Char) -> (Bool, M.Map Char Char)
            addCharFirst acc'@(goodSoFar, inMap) (chSquare, chWord)
              | not goodSoFar = acc'
              | isNothing lookupVal && notMappedAlready = (True, M.insert chWord chSquare inMap)
              | lookupVal == Just chSquare = acc'
              | otherwise = (False, inMap)
              where
                lookupVal = M.lookup chWord inMap
                notMappedAlready = isNothing (find (== chSquare) (map snd (M.toList inMap)))

            -- Take the mapping from the first word and square and generate the number corresponding
            -- to the second word, and accumulate the value of the associated square at the same
            -- time.

            checkAndAccumSecond :: Int -> Char -> Int
            checkAndAccumSecond acc' ch = newAcc
              where
                newAcc = (10 * acc') + mappedNumber
                mappedDigit = fromJust (M.lookup ch firstMapping)
                mappedNumber = ord mappedDigit - ord0

    -- Walk through a sorted list of pairs, where the second is a word and the first a sorted list
    -- of the characters in the word.  Return a list of all where there are two or more in a row
    -- with identical character lists.

    keepOnlyAnagrams :: [(BC.ByteString, BC.ByteString)] -> Bool
                            -> [(BC.ByteString, BC.ByteString)]
    keepOnlyAnagrams [] _ = []
    keepOnlyAnagrams [pr] True = [pr]
    keepOnlyAnagrams [_] False = []
    keepOnlyAnagrams ((s1, w1) : (s2, w2) : xs) includeCurrent
      | s1 == s2 = (s1, w1) : keepOnlyAnagrams ((s2, w2) : xs) True
      | includeCurrent = (s1, w1) : keepOnlyAnagrams ((s2, w2) : xs) False
      | otherwise = keepOnlyAnagrams ((s2, w2) : xs) False

    -- Generate a list of lists of all squares with a specific number of digits.

    genSquareStrs :: Int -> Int -> Int -> [BC.ByteString] -> [[BC.ByteString]] -> [[BC.ByteString]]
    genSquareStrs n nextLimit limit currSquares squareLists
      | nSq >= limit = reverse (revCurrSquares : squareLists)
      | nSq >= nextLimit
        = genSquareStrs (n + 1) (nextLimit * 10) limit [nSqStr] (revCurrSquares : squareLists)
      | otherwise = genSquareStrs (n + 1) nextLimit limit (nSqStr : currSquares) squareLists
      where
        nSq = n * n
        nSqStr = BC.pack (show nSq)
        revCurrSquares = reverse currSquares

-- Here use log(b^p) = p * log(b).  Super easy, but I have to admit that I didn't think of it right
-- away, and instead tried all sorts of convoluted things with prime factors and highest bits before
-- thinking of this.  Incidentally, doing the full comparisons of the full numbers (b^p) in Haskell
-- using Integer took just over a minute.

prob099 :: IO Int
prob099 = do
  fileContents <- BC.readFile inFileName
  let linedFileContents = BC.lines fileContents
      wordFileContents = map (BC.split ',') linedFileContents
      intFileContentsL = map convertByteStringsToInts wordFileContents
      linesAndLogs = zipWith genPowerLog [1..] intFileContentsL
      lineNumb = fst (maximumBy (\acc newVal -> compare (snd acc) (snd newVal)) linesAndLogs)
  return lineNumb
  where
    inFileName = "prob099_in.txt"
    genPowerLog :: Int -> [Int] -> (Int, Double)
    genPowerLog n baseAndPower
      | length baseAndPower == 2 = let [base, power] = baseAndPower
                                   in  (n, fromIntegral power * log (fromIntegral base))
      | otherwise = error "Error: Entry in problem 99 input without two entries."

-- Here we take the basic equation b/t * (b-1)/(t-1) = 1/2 and convert it by completing the square
-- to: (2(t-1/2))^2 - 2(2(b-1/2))^2 = -1  By substituting for two new variables we get:
-- s^2 - 2*y^2 = -1, which is a diophantine equation, and more specifically, the variant of Pell's
-- Equation where it is equal to -1.  Solve it and then substitute to find the number of blue chips
-- and total chips, and search until we find a solution big enough.

prob100 :: Integer
prob100 = (fst . head) bigEnough
  where
    bigEnough = dropWhile (\(_, total) -> total < 1000000000000) blueTotalVals
    blueTotalVals = map (\(m, n) -> let blue = (n + 1) `quot` 2
                                        total = (m + 1) `quot` 2
                                    in  (blue, total)) goodPairs
    goodPairs = filter (\(m, n) -> odd m && odd n) potentialPairs
    potentialPairs = pellsEquationNegOneSolutions 2

